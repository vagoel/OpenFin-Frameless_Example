/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/of-main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/api/application/application.ts":
/*!********************************************!*\
  !*** ./src/api/application/application.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst window_1 = __webpack_require__(/*! ../window/window */ \"./src/api/window/window.ts\");\nconst validate_1 = __webpack_require__(/*! ../../util/validate */ \"./src/util/validate.ts\");\nclass NavigationRejectedReply extends base_1.Reply {\n}\nexports.NavigationRejectedReply = NavigationRejectedReply;\n/**\n * @typedef {object} ApplicationOption\n * @summary Application creation options.\n * @desc This is the options object required by {@link Application.start Application.start}.\n *\n * The following options are required:\n * * `uuid` is required in the app manifest as well as by {@link Application.start Application.start}\n * * `name` is optional in the app manifest but required by {@link Application.start Application.start}\n * * `url` is optional in both the app manifest {@link Application.start Application.start} and  but is usually given\n * (defaults to `\"about:blank\"` when omitted).\n *\n * _This jsdoc typedef mirrors the `ApplicationOption` TypeScript interface in `@types/openfin`._\n *\n * **IMPORTANT NOTE:**\n * This object inherits all the properties of the window creation {@link Window~options options} object,\n * which will take priority over those of the same name that may be provided in `mainWindowOptions`.\n *\n * @property {boolean} [disableIabSecureLogging=false]\n * When set to `true` it will disable IAB secure logging for the app.\n *\n * @property {string} [loadErrorMessage=\"There was an error loading the application.\"]\n * An error message to display when the application (launched via manifest) fails to load.\n * A dialog box will be launched with the error message just before the runtime exits.\n * Load fails such as failed DNS resolutions or aborted connections as well as cancellations, _e.g.,_ `window.stop()`,\n * will trigger this dialog.\n * Client response codes such as `404 Not Found` are not treated as fails as they are valid server responses.\n *\n * @property {Window~options} [mainWindowOptions]\n * The options of the main window of the application.\n * For a description of these options, click the link (in the Type column).\n *\n * @property {string} [name]\n * The name of the application (and the application's main window).\n *\n * If provided, _must_ match `uuid`.\n *\n * @property {boolean} [nonPersistent=false]\n * A flag to configure the application as non-persistent.\n * Runtime exits when there are no persistent apps running.\n *\n * @property {boolean} [plugins=false]\n * Enable Flash at the application level.\n *\n * @property {boolean} [spellCheck=false]\n * Enable spell check at the application level.\n *\n * @property {string} [url=\"about:blank\"]\n * The url to the application (specifically the application's main window).\n *\n * @property {string} uuid\n * The _Unique Universal Identifier_ (UUID) of the application, unique within the set of all other applications\n *  running in the OpenFin Runtime.\n *\n * Note that `name` and `uuid` must match.\n *\n * @property {boolean} [webSecurity=true]\n * When set to `false` it will disable the same-origin policy for the app.\n */\n/**\n * @lends Application\n */\nclass ApplicationModule extends base_1.Base {\n    /**\n     * Asynchronously returns an Application object that represents an existing application.\n     * @param { Identity } identity\n     * @return {Promise.<Application>}\n     * @tutorial Application.wrap\n     * @static\n     */\n    async wrap(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new Application(this.wire, identity);\n    }\n    /**\n     * Synchronously returns an Application object that represents an existing application.\n     * @param { Identity } identity\n     * @return {Application}\n     * @tutorial Application.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new Application(this.wire, identity);\n    }\n    // tslint:disable-next-line:function-name\n    async _create(appOptions) {\n        //set defaults:\n        if (appOptions.waitForPageLoad === void 0) {\n            appOptions.waitForPageLoad = false;\n        }\n        if (appOptions.autoShow === void 0) {\n            appOptions.autoShow = true;\n        }\n        await this.wire.sendAction('create-application', appOptions);\n        return await this.wrap({ uuid: appOptions.uuid });\n    }\n    /**\n    * DEPRECATED method to create a new Application. Use {@link Application.start} instead.\n    * @param { ApplicationOption } appOptions\n    * @return {Promise.<Application>}\n    * @tutorial Application.create\n    * @ignore\n    */\n    create(appOptions) {\n        console.warn('Deprecation Warning: fin.Application.create is deprecated. Please use fin.Application.start');\n        return this._create(appOptions);\n    }\n    /**\n    * Creates and starts a new Application.\n    * @param { ApplicationOption } appOptions\n    * @return {Promise.<Application>}\n    * @tutorial Application.start\n    * @static\n    */\n    async start(appOptions) {\n        const app = await this._create(appOptions);\n        await this.wire.sendAction('run-application', { uuid: appOptions.uuid });\n        return app;\n    }\n    /**\n     * Asynchronously starts a batch of applications given an array of application identifiers and manifestUrls.\n     * Returns once the RVM is finished attempting to launch the applications.\n     * @param { Array.<ManifestInfo> } applications\n     * @return {Promise.<void>}\n     * @static\n     * @tutorial Application.startManyManifests\n     * @experimental\n     */\n    async startManyManifests(applications) {\n        return this.wire.sendAction('run-applications', { applications }).then(() => undefined);\n    }\n    /**\n     * Asynchronously returns an Application object that represents the current application\n     * @return {Promise.<Application>}\n     * @tutorial Application.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return this.wrap({ uuid: this.wire.me.uuid });\n    }\n    /**\n     * Synchronously returns an Application object that represents the current application\n     * @return {Application}\n     * @tutorial Application.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return this.wrapSync({ uuid: this.wire.me.uuid });\n    }\n    /**\n     * Retrieves application's manifest and returns a running instance of the application.\n     * @param {string} manifestUrl - The URL of app's manifest.\n     * @return {Promise.<Application>}\n     * @tutorial Application.startFromManifest\n     * @static\n     */\n    async startFromManifest(manifestUrl) {\n        const app = await this._createFromManifest(manifestUrl);\n        //@ts-ignore using private method without warning.\n        await app._run();\n        return app;\n    }\n    createFromManifest(manifestUrl) {\n        console.warn('Deprecation Warning: fin.Application.createFromManifest is deprecated. Please use fin.Application.startFromManifest');\n        return this._createFromManifest(manifestUrl);\n    }\n    // tslint:disable-next-line:function-name\n    _createFromManifest(manifestUrl) {\n        return this.wire.sendAction('get-application-manifest', { manifestUrl })\n            .then(({ payload }) => this.wrap({ uuid: payload.data.startup_app.uuid })\n            .then(app => {\n            app._manifestUrl = manifestUrl;\n            return app;\n        }));\n    }\n}\nexports.default = ApplicationModule;\n/**\n * @classdesc An object representing an application. Allows the developer to create,\n * execute, show/close an application as well as listen to <a href=\"tutorial-Application.EventEmitter.html\">application events</a>.\n * @class\n * @hideconstructor\n */\nclass Application extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['application', identity.uuid]);\n        this.identity = identity;\n        this.window = new window_1._Window(this.wire, {\n            uuid: this.identity.uuid,\n            name: this.identity.uuid\n        });\n    }\n    windowListFromIdentityList(identityList) {\n        const windowList = [];\n        identityList.forEach(identity => {\n            windowList.push(new window_1._Window(this.wire, {\n                uuid: identity.uuid,\n                name: identity.name\n            }));\n        });\n        return windowList;\n    }\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function addListener\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function on\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function once\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Adds a listener to the beginning of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependListener\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * The listener is added to the beginning of the listeners array.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependOnceListener\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Remove a listener from the listener array for the specified event.\n     * Caution: Calling this method changes the array indices in the listener array behind the listener.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function removeListener\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Removes all listeners, or those of the specified event.\n     * @param { string | symbol } [eventType]  - The type of the event.\n     * @return {Promise.<this>}\n     * @function removeAllListeners\n     * @memberof Application\n     * @instance\n     * @tutorial Application.EventEmitter\n     */\n    /**\n     * Determines if the application is currently running.\n     * @return {Promise.<boolean>}\n     * @tutorial Application.isRunning\n     */\n    isRunning() {\n        return this.wire.sendAction('is-application-running', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Closes the application and any child windows created by the application.\n     * Cleans the application from state so it is no longer found in getAllApplications.\n     * @param { boolean } [force = false] Close will be prevented from closing when force is false and\n     *  close-requested has been subscribed to for applications main window.\n     * @return {Promise.<boolean>}\n     * @tutorial Application.quit\n     */\n    async quit(force = false) {\n        await this._close(force);\n        await this.wire.sendAction('destroy-application', Object.assign({ force }, this.identity));\n    }\n    //tslint:disable-next-line:function-name\n    _close(force = false) {\n        return this.wire.sendAction('close-application', Object.assign({}, { force }, this.identity))\n            .then(() => undefined);\n    }\n    close(force = false) {\n        console.warn('Deprecation Warning: Application.close is deprecated Please use Application.quit');\n        return this._close(force);\n    }\n    /**\n     * Retrieves an array of wrapped fin.Windows for each of the applications child windows.\n     * @return {Promise.Array.<_Window>}\n     * @tutorial Application.getChildWindows\n     */\n    getChildWindows() {\n        return this.wire.sendAction('get-child-windows', this.identity)\n            .then(({ payload }) => {\n            const identityList = [];\n            payload.data.forEach((winName) => {\n                identityList.push({ uuid: this.identity.uuid, name: winName });\n            });\n            return this.windowListFromIdentityList(identityList);\n        });\n    }\n    /**\n     * Retrieves an array of active window groups for all of the application's windows. Each group is\n     * represented as an array of wrapped fin.Windows.\n     * @return {Promise.Array.Array.<_Window>}\n     * @tutorial Application.getGroups\n     */\n    getGroups() {\n        const winGroups = [];\n        return this.wire.sendAction('get-application-groups', Object.assign({}, {\n            crossApp: true // cross app group supported\n        }, this.identity)).then(({ payload }) => {\n            payload.data.forEach((windowList, index) => {\n                const identityList = [];\n                windowList.forEach(winInfo => {\n                    identityList.push({ uuid: winInfo.uuid, name: winInfo.windowName });\n                });\n                winGroups[index] = this.windowListFromIdentityList(identityList);\n            });\n            return winGroups;\n        });\n    }\n    /**\n     * Retrieves the JSON manifest that was used to create the application. Invokes the error callback\n     * if the application was not created from a manifest.\n     * @return {Promise.<any>}\n     * @tutorial Application.getManifest\n     */\n    getManifest() {\n        return this.wire.sendAction('get-application-manifest', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves UUID of the application that launches this application. Invokes the error callback\n     * if the application was created from a manifest.\n     * @return {Promise.<string>}\n     * @tutorial Application.getParentUuid\n     */\n    getParentUuid() {\n        return this.wire.sendAction('get-parent-application', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves current application's shortcut configuration.\n     * @return {Promise.<ShortCutConfig>}\n     * @tutorial Application.getShortcuts\n     */\n    getShortcuts() {\n        return this.wire.sendAction('get-shortcuts', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the current zoom level of the application.\n     * @return {Promise.<number>}\n     * @tutorial Application.getZoomLevel\n     */\n    getZoomLevel() {\n        return this.wire.sendAction('get-application-zoom-level', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns an instance of the main Window of the application\n     * @return {Promise.<_Window>}\n     * @tutorial Application.getWindow\n     */\n    getWindow() {\n        return Promise.resolve(this.window);\n    }\n    /**\n    * Manually registers a user with the licensing service. The only data sent by this call is userName and appName.\n    * @param { string } userName - username to be passed to the RVM.\n    * @param { string } appName - app name to be passed to the RVM.\n    * @return {Promise.<void>}\n    * @tutorial Application.registerUser\n    */\n    registerUser(userName, appName) {\n        return this.wire.sendAction('register-user', Object.assign({}, { userName, appName }, this.identity))\n            .then(() => undefined);\n    }\n    /**\n     * Removes the applications icon from the tray.\n     * @return {Promise.<void>}\n     * @tutorial Application.removeTrayIcon\n     */\n    removeTrayIcon() {\n        return this.wire.sendAction('remove-tray-icon', this.identity).then(() => undefined);\n    }\n    /**\n     * Restarts the application.\n     * @return {Promise.<void>}\n     * @tutorial Application.restart\n     */\n    restart() {\n        return this.wire.sendAction('restart-application', this.identity).then(() => undefined);\n    }\n    /**\n     * DEPRECATED method to run the application.\n     * Needed when starting application via {@link Application.create}, but NOT needed when starting via {@link Application.start}.\n     * @return {Promise.<void>}\n     * @tutorial Application.run\n     * @ignore\n     */\n    run() {\n        console.warn('Deprecation Warning: Application.run is deprecated Please use fin.Application.start');\n        return this._run();\n    }\n    // tslint:disable-next-line:function-name\n    _run() {\n        return this.wire.sendAction('run-application', Object.assign({}, {\n            manifestUrl: this._manifestUrl\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Instructs the RVM to schedule one restart of the application.\n     * @return {Promise.<void>}\n     * @tutorial Application.scheduleRestart\n     */\n    scheduleRestart() {\n        return this.wire.sendAction('relaunch-on-close', this.identity).then(() => undefined);\n    }\n    /**\n     * Sends a message to the RVM to upload the application's logs. On success,\n     * an object containing logId is returned.\n     * @return {Promise.<any>}\n     * @tutorial Application.sendApplicationLog\n     */\n    async sendApplicationLog() {\n        const { payload } = await this.wire.sendAction('send-application-log', this.identity);\n        return payload.data;\n    }\n    /**\n     * Adds a customizable icon in the system tray.  To listen for a click on the icon use the `tray-icon-clicked` event.\n     * @param { string } iconUrl Image URL to be used as the icon\n     * @return {Promise.<void>}\n     * @tutorial Application.setTrayIcon\n     */\n    setTrayIcon(iconUrl) {\n        return this.wire.sendAction('set-tray-icon', Object.assign({}, {\n            enabledIcon: iconUrl\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Sets new application's shortcut configuration. Windows only.\n     * @param { ShortCutConfig } config New application's shortcut configuration.\n     * @param { boolean } [config.desktop] - Enable/disable desktop shortcut.\n     * @param { boolean } [config.startMenu] - Enable/disable start menu shortcut.\n     * @param { boolean } [config.systemStartup] - Enable/disable system startup shortcut.\n     * @return {Promise.<void>}\n     * @tutorial Application.setShortcuts\n     */\n    setShortcuts(config) {\n        return this.wire.sendAction('set-shortcuts', Object.assign({}, { data: config }, this.identity))\n            .then(() => undefined);\n    }\n    /**\n     * Sets the zoom level of the application. The original size is 0 and each increment above or below represents zooming 20%\n     * larger or smaller to default limits of 300% and 50% of original size, respectively.\n     * @param { number } level The zoom level\n     * @return {Promise.<void>}\n     * @tutorial Application.setZoomLevel\n     */\n    setZoomLevel(level) {\n        return this.wire.sendAction('set-application-zoom-level', Object.assign({}, { level }, this.identity))\n            .then(() => undefined);\n    }\n    /**\n     * Sets a username to correlate with App Log Management.\n     * @param { string } username Username to correlate with App's Log.\n     * @return {Promise.<void>}\n     * @tutorial Application.setAppLogUsername\n     */\n    async setAppLogUsername(username) {\n        await this.wire.sendAction('set-app-log-username', Object.assign({ data: username }, this.identity));\n    }\n    /**\n     * @summary Retrieves information about the system tray.\n     * @desc The only information currently returned is the position and dimensions.\n     * @return {Promise.<TrayInfo>}\n     * @tutorial Application.getTrayIconInfo\n     */\n    getTrayIconInfo() {\n        return this.wire.sendAction('get-tray-icon-info', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Closes the application by terminating its process.\n     * @return {Promise.<void>}\n     * @tutorial Application.terminate\n     */\n    terminate() {\n        return this.wire.sendAction('terminate-application', this.identity).then(() => undefined);\n    }\n    /**\n     * Waits for a hanging application. This method can be called in response to an application\n     * \"not-responding\" to allow the application to continue and to generate another \"not-responding\"\n     * message after a certain period of time.\n     * @return {Promise.<void>}\n     * @ignore\n     */\n    wait() {\n        return this.wire.sendAction('wait-for-hung-application', this.identity).then(() => undefined);\n    }\n    /**\n     * Retrieves information about the application.\n     * @return {Promise.<ApplicationInfo>}\n     * @tutorial Application.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-info', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports.Application = Application;\n\n\n//# sourceURL=webpack:///./src/api/application/application.ts?");

/***/ }),

/***/ "./src/api/base.ts":
/*!*************************!*\
  !*** ./src/api/base.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst promises_1 = __webpack_require__(/*! ../util/promises */ \"./src/util/promises.ts\");\nclass Base {\n    constructor(wire) {\n        this.isNodeEnvironment = () => {\n            return this.wire.environment.constructor.name === 'NodeEnvironment';\n        };\n        this.isOpenFinEnvironment = () => {\n            return this.wire.environment.constructor.name === 'OpenFinEnvironment';\n        };\n        this.wire = wire;\n    }\n    get topic() {\n        return this._topic || this.constructor.name.replace('_', '').toLowerCase();\n    }\n    set topic(t) {\n        this._topic = t;\n    }\n    get me() {\n        return this.wire.me;\n    }\n}\nexports.Base = Base;\nclass EmitterBase extends Base {\n    constructor(wire, emitterAccessor) {\n        super(wire);\n        this.emitterAccessor = emitterAccessor;\n        this.eventNames = () => this.hasEmitter() ? this.getEmitter().eventNames() : [];\n        this.emit = (eventName, payload, ...args) => {\n            return this.hasEmitter()\n                ? this.getEmitter().emit(eventName, payload, ...args)\n                : false;\n        };\n        this.hasEmitter = () => this.wire.eventAggregator.has(this.emitterAccessor);\n        this.getEmitter = () => this.wire.eventAggregator.get(this.emitterAccessor);\n        this.listeners = (type) => this.hasEmitter() ? this.getEmitter().listeners(type) : [];\n        this.listenerCount = (type) => this.hasEmitter() ? this.getEmitter().listenerCount(type) : 0;\n        this.registerEventListener = async (eventType, options = {}) => {\n            const runtimeEvent = Object.assign({}, this.identity, {\n                timestamp: options.timestamp || Date.now(),\n                topic: this.topic,\n                type: eventType\n            });\n            const emitter = this.getEmitter();\n            const refCount = emitter.listenerCount(runtimeEvent.type);\n            if (!refCount) {\n                await this.wire.sendAction('subscribe-to-desktop-event', runtimeEvent);\n            }\n            return emitter;\n        };\n        this.deregisterEventListener = async (eventType, options = {}) => {\n            if (this.hasEmitter()) {\n                const runtimeEvent = Object.assign({}, this.identity, {\n                    timestamp: options.timestamp || Date.now(),\n                    topic: this.topic,\n                    type: eventType\n                });\n                const emitter = this.getEmitter();\n                const refCount = emitter.listenerCount(runtimeEvent.type);\n                const newRefCount = refCount - 1;\n                if (newRefCount === 0) {\n                    await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);\n                    if (emitter.eventNames && emitter.eventNames().length === 0) {\n                        this.wire.eventAggregator.delete(this.emitterAccessor);\n                        return;\n                    }\n                }\n                return emitter;\n            }\n            // This will only be reached if unsubscribe from event that does not exist but do not want to error here\n            return Promise.resolve();\n        };\n        this.on = async (eventType, listener, options) => {\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.on(eventType, listener);\n            return this;\n        };\n        this.addListener = this.on;\n        this.once = async (eventType, listener, options) => {\n            const deregister = () => this.deregisterEventListener(eventType);\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.once(eventType, deregister);\n            emitter.once(eventType, listener);\n            return this;\n        };\n        this.prependListener = async (eventType, listener, options) => {\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.prependListener(eventType, listener);\n            return this;\n        };\n        this.prependOnceListener = async (eventType, listener, options) => {\n            const deregister = () => this.deregisterEventListener(eventType);\n            const emitter = await this.registerEventListener(eventType, options);\n            emitter.prependOnceListener(eventType, listener);\n            emitter.once(eventType, deregister);\n            return this;\n        };\n        this.removeListener = async (eventType, listener, options) => {\n            const emitter = await this.deregisterEventListener(eventType, options);\n            if (emitter) {\n                emitter.removeListener(eventType, listener);\n            }\n            return this;\n        };\n        this.deregisterAllListeners = async (eventType) => {\n            const runtimeEvent = Object.assign({}, this.identity, {\n                type: eventType,\n                topic: this.topic\n            });\n            if (this.hasEmitter()) {\n                await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent);\n                const emitter = this.getEmitter();\n                emitter.removeAllListeners(eventType);\n                if (emitter.eventNames().length === 0) {\n                    this.wire.eventAggregator.delete(this.emitterAccessor);\n                    return;\n                }\n                return emitter;\n            }\n        };\n        this.removeAllListeners = async (eventType) => {\n            const removeByEvent = async (event) => {\n                const emitter = await this.deregisterAllListeners(event);\n                if (emitter) {\n                    emitter.removeAllListeners(event);\n                }\n            };\n            if (eventType) {\n                await removeByEvent(eventType);\n            }\n            else if (this.hasEmitter()) {\n                const events = this.getEmitter().eventNames();\n                await promises_1.promiseMap(events, removeByEvent);\n            }\n            return this;\n        };\n        this.listeners = (event) => this.hasEmitter()\n            ? this.getEmitter().listeners(event)\n            : [];\n    }\n}\nexports.EmitterBase = EmitterBase;\nclass Reply {\n}\nexports.Reply = Reply;\n\n\n//# sourceURL=webpack:///./src/api/base.ts?");

/***/ }),

/***/ "./src/api/browserview/browserview.ts":
/*!********************************************!*\
  !*** ./src/api/browserview/browserview.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webcontents_1 = __webpack_require__(/*! ../webcontents/webcontents */ \"./src/api/webcontents/webcontents.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nclass BrowserViewModule extends base_1.Base {\n    async create(options) {\n        const uuid = this.wire.me.uuid;\n        await this.wire.sendAction('create-browser-view', Object.assign({}, options, { uuid }));\n        return this.wrapSync({ uuid, name: options.name });\n    }\n    wrapSync(identity) {\n        return new BrowserView(this.wire, identity);\n    }\n}\nexports.BrowserViewModule = BrowserViewModule;\nclass BrowserView extends webcontents_1.WebContents {\n    constructor(wire, identity) {\n        super(wire, identity, 'browserview');\n        this.identity = identity;\n        this.attach = async (target) => {\n            await this.wire.sendAction('attach-browser-view', Object.assign({ target }, this.identity));\n        };\n        this.show = async (target) => {\n            await this.wire.sendAction('show-browser-view', Object.assign({ target }, this.identity));\n        };\n        this.hide = async (target) => {\n            await this.wire.sendAction('hide-browser-view', Object.assign({ target }, this.identity));\n        };\n        this.setBounds = async (bounds) => {\n            await this.wire.sendAction('set-browser-view-bounds', Object.assign({ bounds }, this.identity));\n        };\n        this.getInfo = async () => {\n            const ack = await this.wire.sendAction('get-browser-view-info', Object.assign({}, this.identity));\n            return ack.payload.data;\n        };\n    }\n}\nexports.BrowserView = BrowserView;\n\n\n//# sourceURL=webpack:///./src/api/browserview/browserview.ts?");

/***/ }),

/***/ "./src/api/clipboard/clipboard.ts":
/*!****************************************!*\
  !*** ./src/api/clipboard/clipboard.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * WriteRequestType interface\n * @typedef { object } WriteRequestType\n * @property { string } name The name of the running application\n * @property { string } uuid The uuid of the running application\n */\n/**\n * The Clipboard API allows reading and writing to the clipboard in multiple formats.\n * @namespace\n*/\nclass Clipboard extends base_1.Base {\n    /**\n     * Writes data into the clipboard as plain text\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typeof\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeText\n    */\n    writeText(writeObj) {\n        return this.wire.sendAction('clipboard-write-text', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as plain text\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readText\n    */\n    readText(type) {\n        return this.wire.sendAction('clipboard-read-text', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard as Html\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeHtml\n    */\n    writeHtml(writeObj) {\n        return this.wire.sendAction('clipboard-write-html', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as Html\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readHtml\n    */\n    readHtml(type) {\n        return this.wire.sendAction('clipboard-read-html', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard as Rtf\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.writeRtf\n    */\n    writeRtf(writeObj) {\n        return this.wire.sendAction('clipboard-write-rtf', writeObj).then(() => undefined);\n    }\n    /**\n     * Read the content of the clipboard as Rtf\n     * @param { string } type Clipboard Type\n     * @return {Promise.<string>}\n     * @tutorial Clipboard.readRtf\n    */\n    readRtf(type) {\n        return this.wire.sendAction('clipboard-read-rtf', type)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Writes data into the clipboard\n     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef\n     * @return {Promise.<void>}\n     * @tutorial Clipboard.write\n    */\n    write(writeObj) {\n        return this.wire.sendAction('clipboard-write', writeObj).then(() => undefined);\n    }\n    /**\n     * Reads available formats for the clipboard type\n     * @param { string } type Clipboard Type\n     * @return {Promise.Array.<string>}\n     * @tutorial Clipboard.getAvailableFormats\n    */\n    getAvailableFormats(type) {\n        return this.wire.sendAction('clipboard-read-formats', type)\n            .then(({ payload }) => payload.data);\n    }\n}\nexports.default = Clipboard;\n\n\n//# sourceURL=webpack:///./src/api/clipboard/clipboard.ts?");

/***/ }),

/***/ "./src/api/events/emitterMap.ts":
/*!**************************************!*\
  !*** ./src/api/events/emitterMap.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nclass EmitterMap {\n    constructor() {\n        this.storage = new Map();\n    }\n    hashKeys(keys) {\n        const hashed = keys.map(normalizeString);\n        return hashed.join('/');\n    }\n    get(keys) {\n        const hash = this.hashKeys(keys);\n        if (!this.storage.has(hash)) {\n            this.storage.set(hash, new events_1.EventEmitter());\n        }\n        return this.storage.get(hash);\n    }\n    has(keys) {\n        return this.storage.has(this.hashKeys(keys));\n    }\n    delete(keys) {\n        const hash = this.hashKeys(keys);\n        return this.storage.delete(hash);\n    }\n}\nexports.EmitterMap = EmitterMap;\nfunction normalizeString(s) {\n    const b = new Buffer(s);\n    return b.toString('base64');\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/api/events/emitterMap.ts?");

/***/ }),

/***/ "./src/api/events/eventAggregator.ts":
/*!*******************************************!*\
  !*** ./src/api/events/eventAggregator.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst emitterMap_1 = __webpack_require__(/*! ./emitterMap */ \"./src/api/events/emitterMap.ts\");\nfunction isEventMessage(message) {\n    return message.action === 'process-desktop-event';\n}\nfunction isNotificationMessage(message) {\n    return message.action === 'process-notification-event';\n}\nconst buildLocalPayload = (rawPayload) => {\n    const { payload: { message }, type } = rawPayload;\n    const payload = {};\n    switch (type) {\n        case 'message':\n            payload.message = message;\n            break;\n        case 'show':\n        case 'error':\n        case 'click':\n        case 'close':\n        default: break;\n    }\n    return payload;\n};\nfunction mapKeyFromEvent(event) {\n    const { topic } = event;\n    if (topic === 'frame') {\n        const { uuid, name } = event;\n        return [topic, uuid, name];\n    }\n    else if (topic === 'window') {\n        const { uuid, name } = event;\n        return [topic, uuid, name];\n    }\n    else if (topic === 'application') {\n        const { uuid } = event;\n        return [topic, uuid];\n    }\n    else if (topic === 'external-window') {\n        const { uuid } = event;\n        return [topic, uuid];\n    }\n    return [topic];\n}\nclass EventAggregator extends emitterMap_1.EmitterMap {\n    constructor() {\n        super(...arguments);\n        this.dispatchEvent = (message) => {\n            if (isEventMessage(message)) {\n                const { payload } = message;\n                const accessor = mapKeyFromEvent(payload);\n                if (this.has(accessor)) {\n                    this.get(accessor).emit(payload.type, payload);\n                    return true;\n                }\n            }\n            else if (isNotificationMessage(message)) {\n                const { payload: { notificationId }, type } = message.payload;\n                const accessor = ['notification', '' + notificationId];\n                if (this.has(accessor)) {\n                    this.get(accessor).emit(type, buildLocalPayload(message.payload));\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n}\nexports.EventAggregator = EventAggregator;\n\n\n//# sourceURL=webpack:///./src/api/events/eventAggregator.ts?");

/***/ }),

/***/ "./src/api/external-application/external-application.ts":
/*!**************************************************************!*\
  !*** ./src/api/external-application/external-application.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * @lends ExternalApplication\n */\nclass ExternalApplicationModule extends base_1.Base {\n    /**\n     * Asynchronously returns an External Application object that represents an external application.\n     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)\n     * provided its uuid is already known.\n     * @param {string} uuid The UUID of the external application to be wrapped\n     * @return {Promise.<ExternalApplication>}\n     * @tutorial ExternalApplication.wrap\n     * @static\n     */\n    wrap(uuid) {\n        return Promise.resolve(new ExternalApplication(this.wire, { uuid }));\n    }\n    /**\n     * Synchronously returns an External Application object that represents an external application.\n     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)\n     * provided its uuid is already known.\n     * @param {string} uuid The UUID of the external application to be wrapped\n     * @return {ExternalApplication}\n     * @tutorial ExternalApplication.wrapSync\n     * @static\n     */\n    wrapSync(uuid) {\n        return new ExternalApplication(this.wire, { uuid });\n    }\n}\nexports.default = ExternalApplicationModule;\n/**\n * @classdesc An ExternalApplication object representing native language adapter connections to the runtime. Allows\n * the developer to listen to <a href=\"tutorial-ExternalApplication.EventEmitter.html\">application events.</a>\n * Discovery of connections is provided by <a href=\"tutorial-System.getAllExternalApplications.html\">getAllExternalApplications.</a>\n *\n * Processes that can be wrapped as `ExternalApplication`s include the following:\n * - Processes which have connected to an OpenFin runtime via an adapter\n * - Processes started via `System.launchExternalApplication`\n * - Processes monitored via `System.monitorExternalProcess`\n * @class\n * @hideconstructor\n */\nclass ExternalApplication extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['external-application', identity.uuid]);\n        this.identity = identity;\n    }\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function addListener\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function on\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function once\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Adds a listener to the beginning of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependListener\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * The listener is added to the beginning of the listeners array.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependOnceListener\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Remove a listener from the listener array for the specified event.\n     * Caution: Calling this method changes the array indices in the listener array behind the listener.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function removeListener\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Removes all listeners, or those of the specified event.\n     * @param { string | symbol } [eventType]  - The type of the event.\n     * @return {Promise.<this>}\n     * @function removeAllListeners\n     * @memberof ExternalApplication\n     * @instance\n     * @tutorial ExternalApplication.EventEmitter\n     */\n    /**\n     * Retrieves information about the external application.\n     * @return {Promise.<ExternalApplicationInfo>}\n     * @tutorial ExternalApplication.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-external-application-info', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports.ExternalApplication = ExternalApplication;\n\n\n//# sourceURL=webpack:///./src/api/external-application/external-application.ts?");

/***/ }),

/***/ "./src/api/external-window/external-window.ts":
/*!****************************************************!*\
  !*** ./src/api/external-window/external-window.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst window_1 = __webpack_require__(/*! ../window/window */ \"./src/api/window/window.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * @lends ExternalWindow\n */\nclass ExternalWindowModule extends base_1.Base {\n    /**\n     * Asynchronously returns an external window object that represents\n     * an existing external window.<br>\n     * Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @param { Identity } identity\n     * @return {Promise.<ExternalWindow>}\n     * @static\n     * @experimental\n     * @tutorial Window.wrap\n     */\n    async wrap(identity) {\n        await this.wire.sendAction('register-native-external-window', identity);\n        return new ExternalWindow(this.wire, identity);\n    }\n}\nexports.default = ExternalWindowModule;\n/**\n * @classdesc An ExternalWindow is an OpenFin object representing a window that belongs to a non-openfin application.<br>\n * While External Windows don't have the complete functionality of an OpenFin Window object,\n * they can be used to tap into any application that is currently running in the OS.<br>\n * External Windows are useful for grouping, moving and resizing non-openfin applications\n * as well as listening to events that are dispatched by these applications.<br>\n * They are also compatible with OpenFin's Layouts service to facilitate\n * a complete positional control over all running applications.<br>\n * External Windows has the ability to listen for <a href=\"tutorial-ExternalWindow.EventEmitter.html\"> external window specific events</a>.\n * @class\n * @alias ExternalWindow\n * @hideconstructor\n */\nclass ExternalWindow extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['external-window', identity.uuid]);\n        this.identity = identity;\n        this.topic = 'external-window';\n    }\n    /**\n     * Brings the external window to the front of the window stack.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.bringToFront\n     */\n    async bringToFront() {\n        await this.wire.sendAction('bring-external-window-to-front', this.identity);\n    }\n    /**\n     * Closes the external window.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.close\n    */\n    async close() {\n        await this.wire.sendAction('close-external-window', this.identity);\n        Object.setPrototypeOf(this, null);\n    }\n    /**\n     * Flashes the external windows frame and taskbar icon until stopFlashing is called.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.flash\n     */\n    async flash() {\n        await this.wire.sendAction('flash-external-window', this.identity);\n    }\n    /**\n     * Gives focus to the external window.\n     * @return {Promise.<void>}\n     * @emits ExternalWindow#focused\n     * @experimental\n     * @tutorial Window.focus\n     */\n    async focus() {\n        await this.wire.sendAction('focus-external-window', this.identity);\n    }\n    /**\n     * Gets the current bounds (top, left, etc.) of the external window.\n     * @return {Promise.<Bounds>}\n     * @experimental\n     * @tutorial Window.getBounds\n    */\n    async getBounds() {\n        const { payload: { data } } = await this.wire.sendAction('get-external-window-bounds', this.identity);\n        return data;\n    }\n    /**\n     * Retrieves an array containing wrapped external windows that are grouped\n     * with this external window. If a window is not in a group an empty array\n     * is returned.\n     * @return {Promise.<Array<ExternalWindow|_Window>>}\n     * @experimental\n     * @tutorial Window.getGroup\n     */\n    async getGroup() {\n        const { payload: { data } } = await this.wire.sendAction('get-external-window-group', this.identity);\n        if (!data.length) {\n            return [];\n        }\n        return data.map(({ uuid, name, isExternalWindow }) => {\n            if (isExternalWindow) {\n                return new ExternalWindow(this.wire, { uuid });\n            }\n            else {\n                return new window_1._Window(this.wire, { uuid, name });\n            }\n        });\n    }\n    /**\n     * Gets an information object for the window.\n     * @return {Promise.<any>}\n     * @experimental\n     * @tutorial Window.getInfo\n     */\n    async getInfo() {\n        const { payload: { data } } = await this.wire.sendAction('get-external-window-info', this.identity);\n        return data;\n    }\n    /**\n     * Gets an external window's options.\n     * @return {Promise.<any>}\n     * @experimental\n     * @tutorial Window.getOptions\n     */\n    async getOptions() {\n        const { payload: { data } } = await this.wire.sendAction('get-external-window-options', this.identity);\n        return data;\n    }\n    /**\n     * Gets the current state (\"minimized\", \"maximized\", or \"restored\") of\n     * the external window.\n     * @return {Promise.<string>}\n     * @experimental\n     * @tutorial Window.getState\n     */\n    async getState() {\n        const { payload: { data } } = await this.wire.sendAction('get-external-window-state', this.identity);\n        return data;\n    }\n    /**\n     * Hides the external window.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.hide\n     */\n    async hide() {\n        await this.wire.sendAction('hide-external-window', this.identity);\n    }\n    /**\n     * Determines if the external window is currently showing.\n     * @return {Promise.<boolean>}\n     * @experimental\n     * @tutorial Window.isShowing\n     */\n    async isShowing() {\n        const { payload: { data } } = await this.wire.sendAction('is-external-window-showing', this.identity);\n        return data;\n    }\n    /**\n     * Joins the same window group as the specified window. Currently unsupported (method will nack).\n     * @param { _Window | ExternalWindow } target The window whose group is to be joined\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.joinGroup\n     */\n    async joinGroup(target) {\n        const { identity: { uuid, name } } = target;\n        const targetIdentity = { groupingUuid: uuid, groupingWindowName: name };\n        const payload = Object.assign({}, this.identity, targetIdentity);\n        await this.wire.sendAction('join-external-window-group', payload);\n    }\n    /**\n     * Leaves the current window group so that the window can be moved\n     * independently of those in the group.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.leaveGroup\n     */\n    async leaveGroup() {\n        await this.wire.sendAction('leave-external-window-group', this.identity);\n    }\n    /**\n     * Maximizes the external window.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.maximize\n     */\n    async maximize() {\n        await this.wire.sendAction('maximize-external-window', this.identity);\n    }\n    /**\n     * Merges the instance's window group with the same window group as the specified window\n     * @param { _Window | ExternalWindow } target The window whose group is to be merged with\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.mergeGroups\n     */\n    async mergeGroups(target) {\n        const { identity: { uuid, name } } = target;\n        const targetIdentity = { groupingUuid: uuid, groupingWindowName: name };\n        const payload = Object.assign({}, this.identity, targetIdentity);\n        await this.wire.sendAction('merge-external-window-groups', payload);\n    }\n    /**\n     * Minimizes the external window.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.minimize\n     */\n    async minimize() {\n        await this.wire.sendAction('minimize-external-window', this.identity);\n    }\n    /**\n     * Moves the external window by a specified amount.\n     * @param { number } deltaLeft The change in the left position of the window\n     * @param { number } deltaTop The change in the top position of the window\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.moveBy\n     */\n    async moveBy(deltaLeft, deltaTop) {\n        const payload = Object.assign({}, this.identity, { deltaLeft, deltaTop });\n        await this.wire.sendAction('move-external-window-by', payload);\n    }\n    /**\n     * Moves the external window to a specified location.\n     * @param { number } left The left position of the window\n     * @param { number } top The top position of the window\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.moveTo\n     */\n    async moveTo(left, top) {\n        const payload = Object.assign({}, this.identity, { left, top });\n        await this.wire.sendAction('move-external-window', payload);\n    }\n    /**\n     * Resizes the external window by a specified amount.\n     * @param { number } deltaWidth The change in the width of the window\n     * @param { number } deltaHeight The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\".\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.resizeBy\n     */\n    async resizeBy(deltaWidth, deltaHeight, anchor) {\n        const payload = Object.assign({}, this.identity, { anchor, deltaHeight: Math.floor(deltaHeight), deltaWidth: Math.floor(deltaWidth) });\n        await this.wire.sendAction('resize-external-window-by', payload);\n    }\n    /**\n     * Resizes the external window to the specified dimensions.\n     * @param { number } width The change in the width of the window\n     * @param { number } height The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\".\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.resizeTo\n     */\n    async resizeTo(width, height, anchor) {\n        const payload = Object.assign({}, this.identity, { anchor, height: Math.floor(height), width: Math.floor(width) });\n        await this.wire.sendAction('resize-external-window', payload);\n    }\n    /**\n     * Restores the external window to its normal state (i.e. unminimized, unmaximized).\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.restore\n     */\n    async restore() {\n        await this.wire.sendAction('restore-external-window', this.identity);\n    }\n    /**\n     * Will bring the external window to the front of the entire stack and\n     * give it focus.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.setAsForeground\n     */\n    async setAsForeground() {\n        await this.wire.sendAction('set-external-window-as-foreground', this.identity);\n    }\n    /**\n     * Sets the external window's size and position.\n     * @property { Bounds } bounds\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.setBounds\n     */\n    async setBounds(bounds) {\n        const payload = Object.assign({}, this.identity, bounds);\n        await this.wire.sendAction('set-external-window-bounds', payload);\n    }\n    /**\n     * Shows the external window if it is hidden.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.show\n     */\n    async show() {\n        await this.wire.sendAction('show-external-window', this.identity);\n    }\n    /**\n     * Shows the external window, if it is hidden, at the specified location.\n     * If the toggle parameter is set to true, the external window will\n     * alternate between showing and hiding.\n     * @param { number } left The left position of the window\n     * @param { number } top The top position of the window\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.showAt\n     */\n    async showAt(left, top) {\n        const payload = Object.assign({}, this.identity, { left: Math.floor(left), top: Math.floor(top) });\n        await this.wire.sendAction('show-external-window-at', payload);\n    }\n    /**\n     * Stops the taskbar icon from flashing.\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.stopFlashing\n     */\n    async stopFlashing() {\n        await this.wire.sendAction('stop-external-window-flashing', this.identity);\n    }\n    /**\n     * Updates the external window using the passed options\n     * @param {*} options Changes an external window's options\n     * @return {Promise.<void>}\n     * @experimental\n     * @tutorial Window.updateOptions\n     */\n    async updateOptions(options) {\n        const payload = Object.assign({}, this.identity, { options });\n        await this.wire.sendAction('update-external-window-options', payload);\n    }\n}\nexports.ExternalWindow = ExternalWindow;\n\n\n//# sourceURL=webpack:///./src/api/external-window/external-window.ts?");

/***/ }),

/***/ "./src/api/fin.ts":
/*!************************!*\
  !*** ./src/api/fin.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst system_1 = __webpack_require__(/*! ./system/system */ \"./src/api/system/system.ts\");\nconst window_1 = __webpack_require__(/*! ./window/window */ \"./src/api/window/window.ts\");\nconst application_1 = __webpack_require__(/*! ./application/application */ \"./src/api/application/application.ts\");\nconst interappbus_1 = __webpack_require__(/*! ./interappbus/interappbus */ \"./src/api/interappbus/interappbus.ts\");\nconst notification_1 = __webpack_require__(/*! ./notification/notification */ \"./src/api/notification/notification.ts\");\nconst clipboard_1 = __webpack_require__(/*! ./clipboard/clipboard */ \"./src/api/clipboard/clipboard.ts\");\nconst external_application_1 = __webpack_require__(/*! ./external-application/external-application */ \"./src/api/external-application/external-application.ts\");\nconst external_window_1 = __webpack_require__(/*! ./external-window/external-window */ \"./src/api/external-window/external-window.ts\");\nconst frame_1 = __webpack_require__(/*! ./frame/frame */ \"./src/api/frame/frame.ts\");\nconst global_hotkey_1 = __webpack_require__(/*! ./global-hotkey */ \"./src/api/global-hotkey/index.ts\");\nconst browserview_1 = __webpack_require__(/*! ./browserview/browserview */ \"./src/api/browserview/browserview.ts\");\nclass Fin extends events_1.EventEmitter {\n    get me() {\n        return this.wire.me;\n    }\n    constructor(wire) {\n        super();\n        this.wire = wire;\n        this.System = new system_1.default(wire);\n        this.Window = new window_1.default(wire);\n        this.Application = new application_1.default(wire);\n        this.InterApplicationBus = new interappbus_1.default(wire);\n        this.Notification = new notification_1.default(wire);\n        this.Clipboard = new clipboard_1.default(wire);\n        this.ExternalApplication = new external_application_1.default(wire);\n        this.ExternalWindow = new external_window_1.default(wire);\n        this.Frame = new frame_1.default(wire);\n        this.GlobalHotkey = new global_hotkey_1.default(wire);\n        this.BrowserView = new browserview_1.BrowserViewModule(wire);\n        //Handle disconnect events\n        wire.on('disconnected', () => {\n            this.emit('disconnected');\n        });\n    }\n}\nexports.default = Fin;\n\n\n//# sourceURL=webpack:///./src/api/fin.ts?");

/***/ }),

/***/ "./src/api/frame/frame.ts":
/*!********************************!*\
  !*** ./src/api/frame/frame.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst validate_1 = __webpack_require__(/*! ../../util/validate */ \"./src/util/validate.ts\");\n/**\n * @lends Frame\n */\n// tslint:disable-next-line\nclass _FrameModule extends base_1.Base {\n    /**\n     * Asynchronously returns a reference to the specified frame. The frame does not have to exist\n     * @param {Identity} identity - the identity of the frame you want to wrap\n     * @return {Promise.<_Frame>}\n     * @tutorial Frame.wrap\n     * @static\n     */\n    async wrap(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new _Frame(this.wire, identity);\n    }\n    /**\n     * Synchronously returns a reference to the specified frame. The frame does not have to exist\n     * @param {Identity} identity - the identity of the frame you want to wrap\n     * @return {_Frame}\n     * @tutorial Frame.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new _Frame(this.wire, identity);\n    }\n    /**\n     * Asynchronously returns a reference to the current frame\n     * @return {Promise.<_Frame>}\n     * @tutorial Frame.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return Promise.resolve(new _Frame(this.wire, this.wire.environment.getCurrentEntityIdentity()));\n    }\n    /**\n     * Synchronously returns a reference to the current frame\n     * @return {_Frame}\n     * @tutorial Frame.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return new _Frame(this.wire, this.wire.environment.getCurrentEntityIdentity());\n    }\n}\nexports.default = _FrameModule;\n/**\n * @classdesc\n * An iframe represents an embedded HTML page within a parent HTML page. Because this embedded page\n * has its own DOM and global JS context (which may or may not be linked to that of the parent depending\n * on if it is considered out of the root domain or not), it represents a unique endpoint as an OpenFin\n * connection. Iframes may be generated dynamically, or be present on initial page load and each non-CORS\n * iframe has the OpenFin API injected by default. It is possible to opt into cross-origin iframes having\n * the API by setting api.iframe.crossOriginInjection to true in a window's options. To block all iframes\n * from getting the API injected you can set api.frame.sameOriginInjection\n * to false <a href=\"Window.html#~options\" target=\"_blank\">(see Window~options)</a>.\n *\n * To be able to directly address this context for eventing and messaging purposes, it needs a\n * unique uuid name pairing. For OpenFin applications and windows this is provided via a configuration\n * object in the form of a manifest URL or options object, but there is no configuration object for iframes.\n * Just as a call to window.open outside of our Window API returns a new window with a random GUID assigned\n * for the name, each iframe that has the API injected will be assigned a GUID as its name, the UUID will be\n * the same as the parent window's.\n *\n * The fin.Frame namespace represents a way to interact with `iframes` and facilitates the discovery of current context\n * (iframe or main window) as well as the ability to listen for <a href=\"tutorial-Frame.EventEmitter.html\">frame-specific events</a>.\n * @class\n * @alias Frame\n * @hideconstructor\n */\n// tslint:disable-next-line\nclass _Frame extends base_1.EmitterBase {\n    constructor(wire, identity) {\n        super(wire, ['frame', identity.uuid, identity.name]);\n        this.identity = identity;\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the specified event type.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function addListener\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function on\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function once\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Adds a listener to the beginning of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependListener\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * The listener is added to the beginning of the listeners array.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependOnceListener\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Remove a listener from the listener array for the specified event.\n     * Caution: Calling this method changes the array indices in the listener array behind the listener.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function removeListener\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Removes all listeners, or those of the specified event.\n     * @param { string | symbol } [eventType]  - The type of the event.\n     * @return {Promise.<this>}\n     * @function removeAllListeners\n     * @memberof Frame\n     * @instance\n     * @tutorial Frame.EventEmitter\n     */\n    /**\n     * Returns a frame info object for the represented frame\n     * @return {Promise.<FrameInfo>}\n     * @tutorial Frame.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-frame-info', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns a frame info object representing the window that the referenced iframe is\n     * currently embedded in\n     * @return {Promise.<FrameInfo>}\n     * @tutorial Frame.getParentWindow\n     */\n    getParentWindow() {\n        return this.wire.sendAction('get-parent-window', this.identity).then(({ payload }) => payload.data);\n    }\n}\nexports._Frame = _Frame;\n\n\n//# sourceURL=webpack:///./src/api/frame/frame.ts?");

/***/ }),

/***/ "./src/api/global-hotkey/index.ts":
/*!****************************************!*\
  !*** ./src/api/global-hotkey/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\n/**\n * The GlobalHotkey module can register/unregister a global hotkeys.\n * @namespace\n */\nclass GlobalHotkey extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['global-hotkey']);\n        this.topic = 'global-hotkey';\n    }\n    /**\n     * Registers a global hotkey with the operating system.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.register\n     */\n    async register(hotkey, listener) {\n        await this.on(hotkey, listener);\n        await this.wire.sendAction(\"global-hotkey-register\" /* REGISTER */, { hotkey });\n        return void 0;\n    }\n    /**\n     * Unregisters a global hotkey with the operating system.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.unregister\n     */\n    async unregister(hotkey) {\n        await this.removeAllListeners(hotkey);\n        await this.wire.sendAction(\"global-hotkey-unregister\" /* UNREGISTER */, { hotkey });\n        return void 0;\n    }\n    /**\n     * Unregisters all global hotkeys for the current application.\n     * @return {Promise.<void>}\n     * @tutorial GlobalHotkey.unregisterAll\n     */\n    async unregisterAll() {\n        await Promise.all(this.eventNames()\n            .filter((name) => !(name === \"registered\" /* REGISTERED */ || name === \"unregistered\" /* UNREGISTERED */))\n            .map((name) => this.removeAllListeners(name)));\n        await this.wire.sendAction(\"global-hotkey-unregister-all\" /* UNREGISTER_ALL */, {});\n        return void 0;\n    }\n    /**\n     * Checks if a given hotkey has been registered\n     * @return {Promise.<bookean>}\n     * @tutorial GlobalHotkey.isRegistered\n     */\n    async isRegistered(hotkey) {\n        const { payload: { data } } = await this.wire.sendAction(\"global-hotkey-is-registered\" /* IS_REGISTERED */, { hotkey });\n        return data;\n    }\n}\nexports.default = GlobalHotkey;\n\n\n//# sourceURL=webpack:///./src/api/global-hotkey/index.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/channel.ts":
/*!************************************************!*\
  !*** ./src/api/interappbus/channel/channel.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst idOrResult = (func) => (...args) => {\n    const res = func(...args);\n    return res === undefined ? args[1] : res;\n};\nclass ChannelBase {\n    constructor(providerIdentity, send) {\n        this.defaultSet = false;\n        this.providerIdentity = providerIdentity;\n        this.subscriptions = new Map();\n        this.defaultAction = () => {\n            throw new Error('No action registered');\n        };\n        this.sendRaw = send;\n        this.send = async (to, action, payload) => {\n            const raw = await send('send-channel-message', Object.assign({}, to, { providerIdentity: this.providerIdentity, action, payload }))\n                .catch(reason => {\n                throw new Error(reason.message);\n            });\n            return raw.payload.data.result;\n        };\n    }\n    async processAction(action, payload, senderIdentity) {\n        try {\n            const mainAction = this.subscriptions.has(action)\n                ? this.subscriptions.get(action)\n                : (payload, id) => this.defaultAction(action, payload, id);\n            const preActionProcessed = this.preAction ? await this.preAction(action, payload, senderIdentity) : payload;\n            const actionProcessed = await mainAction(preActionProcessed, senderIdentity);\n            return this.postAction\n                ? await this.postAction(action, actionProcessed, senderIdentity)\n                : actionProcessed;\n        }\n        catch (e) {\n            if (this.errorMiddleware) {\n                return this.errorMiddleware(action, e, senderIdentity);\n            }\n            throw e;\n        }\n    }\n    beforeAction(func) {\n        if (this.preAction) {\n            throw new Error('Already registered beforeAction middleware');\n        }\n        this.preAction = idOrResult(func);\n    }\n    onError(func) {\n        if (this.errorMiddleware) {\n            throw new Error('Already registered error middleware');\n        }\n        this.errorMiddleware = func;\n    }\n    afterAction(func) {\n        if (this.postAction) {\n            throw new Error('Already registered afterAction middleware');\n        }\n        this.postAction = idOrResult(func);\n    }\n    remove(action) {\n        this.subscriptions.delete(action);\n    }\n    setDefaultAction(func) {\n        if (this.defaultSet) {\n            throw new Error('default action can only be set once');\n        }\n        else {\n            this.defaultAction = func;\n            this.defaultSet = true;\n        }\n    }\n    register(topic, listener) {\n        if (this.subscriptions.has(topic)) {\n            throw new Error(`Subscription already registered for action: ${topic}. Unsubscribe before adding new subscription`);\n        }\n        else {\n            this.subscriptions.set(topic, listener);\n            return true;\n        }\n    }\n}\nexports.ChannelBase = ChannelBase;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/channel.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/client.ts":
/*!***********************************************!*\
  !*** ./src/api/interappbus/channel/client.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_1 = __webpack_require__(/*! ./channel */ \"./src/api/interappbus/channel/channel.ts\");\nclass ChannelClient extends channel_1.ChannelBase {\n    constructor(providerIdentity, send) {\n        super(providerIdentity, send);\n        this.disconnectListener = () => undefined;\n    }\n    async dispatch(action, payload) {\n        return this.send(this.providerIdentity, action, payload);\n    }\n    onDisconnection(listener) {\n        this.disconnectListener = listener;\n    }\n    async disconnect() {\n        const { channelName } = this.providerIdentity;\n        await this.sendRaw('disconnect-from-channel', { channelName });\n        const { channelId } = this.providerIdentity;\n        this.removeChannel(channelId);\n    }\n}\nexports.ChannelClient = ChannelClient;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/client.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/index.ts":
/*!**********************************************!*\
  !*** ./src/api/interappbus/channel/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/api/interappbus/channel/client.ts\");\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./src/api/interappbus/channel/provider.ts\");\nconst base_1 = __webpack_require__(/*! ../../base */ \"./src/api/base.ts\");\nclass Channel extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['channel']);\n        this.onmessage = (msg) => {\n            if (msg.action === 'process-channel-message') {\n                this.processChannelMessage(msg);\n                return true;\n            }\n            else if (msg.action === 'process-channel-connection') {\n                this.processChannelConnection(msg);\n                return true;\n            }\n            return false;\n        };\n        this.topic = 'channel';\n        this.channelMap = new Map();\n        wire.registerMessageHandler(this.onmessage.bind(this));\n    }\n    async getAllChannels() {\n        return this.wire.sendAction('get-all-channels')\n            .then(({ payload }) => payload.data);\n    }\n    async onChannelConnect(listener) {\n        await this.on('connected', listener);\n    }\n    async onChannelDisconnect(listener) {\n        await this.on('disconnected', listener);\n    }\n    async connect(channelName, options) {\n        if (!channelName || typeof channelName !== 'string') {\n            throw new Error('Please provide a channelName string to connect to a channel.');\n        }\n        const opts = options || {};\n        let resolver;\n        let listener;\n        const waitResponse = new Promise(resolve => {\n            resolver = resolve;\n            listener = (payload) => {\n                if (channelName === payload.channelName) {\n                    this.removeListener('connected', listener);\n                    this.connect(channelName, opts).then(response => {\n                        resolve(response);\n                    });\n                }\n            };\n            this.on('connected', listener);\n        });\n        try {\n            const { payload: { data: providerIdentity } } = await this.wire.sendAction('connect-to-channel', Object.assign({ channelName }, opts));\n            // If there isn't a matching channel, the above sendAction call will error out and go to catch, skipping the logic below\n            if (resolver) {\n                resolver();\n            }\n            this.removeListener('connected', listener);\n            const channel = new client_1.ChannelClient(providerIdentity, this.wire.sendAction.bind(this.wire));\n            const key = providerIdentity.channelId;\n            this.channelMap.set(key, channel);\n            //@ts-ignore use of protected property\n            channel.removeChannel = this.removeChannelFromMap.bind(this);\n            this.on('disconnected', (eventPayload) => {\n                if (eventPayload.channelName === channelName) {\n                    this.removeChannelFromMap(key);\n                    //@ts-ignore use of private property\n                    channel.disconnectListener(eventPayload);\n                }\n            });\n            return channel;\n        }\n        catch (e) {\n            const shouldWait = Object.assign({ wait: true }, opts).wait;\n            const internalNackMessage = 'internal-nack';\n            if (shouldWait && e.message && e.message.includes(internalNackMessage)) {\n                console.warn(`Channel not found for channelName: ${channelName}, waiting for channel creation.`);\n                return await waitResponse;\n            }\n            else if (e.message === internalNackMessage) {\n                throw new Error(`No channel found for channelName: ${channelName}`);\n            }\n            else {\n                throw new Error(e);\n            }\n        }\n    }\n    async create(channelName) {\n        if (!channelName) {\n            throw new Error('Please provide a channelName to create a channel');\n        }\n        const { payload: { data: providerIdentity } } = await this.wire.sendAction('create-channel', { channelName });\n        const channel = new provider_1.ChannelProvider(providerIdentity, this.wire.sendAction.bind(this.wire));\n        const key = providerIdentity.channelId;\n        this.channelMap.set(key, channel);\n        //@ts-ignore use of protected property\n        channel.removeChannel = this.removeChannelFromMap.bind(this);\n        this.on('client-disconnected', (eventPayload) => {\n            if (eventPayload.channelName === channelName) {\n                channel.connections = channel.connections.filter(identity => {\n                    return identity.uuid !== eventPayload.uuid || identity.name !== eventPayload.name;\n                });\n                //@ts-ignore use of private property\n                channel.disconnectListener(eventPayload);\n            }\n        });\n        return channel;\n    }\n    removeChannelFromMap(mapKey) {\n        this.channelMap.delete(mapKey);\n    }\n    async processChannelMessage(msg) {\n        const { senderIdentity, providerIdentity, action, ackToSender, payload } = msg.payload;\n        const key = providerIdentity.channelId;\n        const bus = this.channelMap.get(key);\n        if (!bus) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = `Client connection with identity ${JSON.stringify(this.wire.me)} no longer connected.`;\n            return this.wire.sendRaw(ackToSender);\n        }\n        try {\n            const res = await bus.processAction(action, payload, senderIdentity);\n            ackToSender.payload.payload = ackToSender.payload.payload || {};\n            ackToSender.payload.payload.result = res;\n            this.wire.sendRaw(ackToSender);\n        }\n        catch (e) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = e.message;\n            this.wire.sendRaw(ackToSender);\n        }\n    }\n    async processChannelConnection(msg) {\n        const { clientIdentity, providerIdentity, ackToSender, payload } = msg.payload;\n        const key = providerIdentity.channelId;\n        const bus = this.channelMap.get(key);\n        if (!bus) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = `Channel \"${providerIdentity.channelName}\" has been destroyed.`;\n            return this.wire.sendRaw(ackToSender);\n        }\n        try {\n            if (!(bus instanceof provider_1.ChannelProvider)) {\n                throw Error('Cannot connect to a channel client');\n            }\n            const res = await bus.processConnection(clientIdentity, payload);\n            ackToSender.payload.payload = ackToSender.payload.payload || {};\n            ackToSender.payload.payload.result = res;\n            this.wire.sendRaw(ackToSender);\n        }\n        catch (e) {\n            ackToSender.payload.success = false;\n            ackToSender.payload.reason = e.message;\n            this.wire.sendRaw(ackToSender);\n        }\n    }\n}\nexports.Channel = Channel;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/index.ts?");

/***/ }),

/***/ "./src/api/interappbus/channel/provider.ts":
/*!*************************************************!*\
  !*** ./src/api/interappbus/channel/provider.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_1 = __webpack_require__(/*! ./channel */ \"./src/api/interappbus/channel/channel.ts\");\nclass ChannelProvider extends channel_1.ChannelBase {\n    constructor(providerIdentity, send) {\n        super(providerIdentity, send);\n        this.connectListener = () => undefined;\n        this.disconnectListener = () => undefined;\n        this.connections = [];\n    }\n    dispatch(to, action, payload) {\n        return this.send(to, action, payload);\n    }\n    async processConnection(senderId, payload) {\n        this.connections.push(senderId);\n        return this.connectListener(senderId, payload);\n    }\n    publish(action, payload) {\n        return this.connections.map(to => this.send(to, action, payload));\n    }\n    onConnection(listener) {\n        this.connectListener = listener;\n    }\n    onDisconnection(listener) {\n        this.disconnectListener = listener;\n    }\n    async destroy() {\n        const { channelName } = this.providerIdentity;\n        await this.sendRaw('destroy-channel', { channelName });\n        const { channelId } = this.providerIdentity;\n        this.removeChannel(channelId);\n    }\n}\nexports.ChannelProvider = ChannelProvider;\n\n\n//# sourceURL=webpack:///./src/api/interappbus/channel/provider.ts?");

/***/ }),

/***/ "./src/api/interappbus/interappbus.ts":
/*!********************************************!*\
  !*** ./src/api/interappbus/interappbus.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst ref_counter_1 = __webpack_require__(/*! ../../util/ref-counter */ \"./src/util/ref-counter.ts\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst index_1 = __webpack_require__(/*! ./channel/index */ \"./src/api/interappbus/channel/index.ts\");\nconst validate_1 = __webpack_require__(/*! ../../util/validate */ \"./src/util/validate.ts\");\n/**\n * A messaging bus that allows for pub/sub messaging between different applications.\n * @namespace\n*/\nclass InterApplicationBus extends base_1.Base {\n    constructor(wire) {\n        super(wire);\n        this.events = {\n            subscriberAdded: 'subscriber-added',\n            subscriberRemoved: 'subscriber-removed'\n        };\n        this.refCounter = new ref_counter_1.default();\n        //tslint:disable-next-line\n        this.Channel = new index_1.Channel(wire);\n        this.emitter = new events_1.EventEmitter();\n        wire.registerMessageHandler(this.onmessage.bind(this));\n        this.on = this.emitter.on.bind(this.emitter);\n        this.removeAllListeners = this.emitter.removeAllListeners.bind(this.emitter);\n    }\n    /**\n     * Publishes a message to all applications running on OpenFin Runtime that\n     * are subscribed to the specified topic.\n     * @param { string } topic The topic on which the message is sent\n     * @param { any } message The message to be published. Can be either a primitive\n     * data type (string, number, or boolean) or composite data type (object, array)\n     * that is composed of other primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.publish\n    */\n    publish(topic, message) {\n        return this.wire.sendAction('publish-message', {\n            topic,\n            message,\n            sourceWindowName: this.me.name\n        }).then(() => undefined);\n    }\n    /**\n     * Sends a message to a specific application on a specific topic.\n     * @param { Identity } destination The identity of the application to which the message is sent\n     * @param { string } topic The topic on which the message is sent\n     * @param { any } message The message to be sent. Can be either a primitive data\n     * type (string, number, or boolean) or composite data type (object, array) that\n     * is composed of other primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.send\n    */\n    async send(destination, topic, message) {\n        const errorMsg = validate_1.validateIdentity(destination);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        await this.wire.sendAction('send-message', {\n            destinationUuid: destination.uuid,\n            destinationWindowName: destination.name,\n            topic,\n            message,\n            sourceWindowName: this.me.name\n        });\n    }\n    /**\n     * Subscribes to messages from the specified application on the specified topic.\n     * If the subscription is for a uuid, [name], topic combination that has already\n     * been published to upon subscription you will receive the last 20 missed messages\n     * in the order they were published.\n     * @param { Identity } source This object is described in the Identity in the typedef\n     * @param { string } topic The topic on which the message is sent\n     * @param { function } listener A function that is called when a message has\n     * been received. It is passed the message, uuid and name of the sending application.\n     * The message can be either a primitive data type (string, number, or boolean) or\n     * composite data type (object, array) that is composed of other primitive or composite\n     * data types\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.subcribe\n     */\n    subscribe(source, topic, listener) {\n        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);\n        const sendSubscription = () => {\n            return this.wire.sendAction('subscribe', {\n                sourceUuid: source.uuid,\n                sourceWindowName: source.name || '*',\n                topic,\n                destinationWindowName: this.me.name\n            });\n        };\n        const alreadySubscribed = () => {\n            // tslint:disable-next-line\n            return new Promise(r => r).then(() => undefined);\n        };\n        this.emitter.on(subKey, listener);\n        return this.refCounter.actOnFirst(subKey, sendSubscription, alreadySubscribed);\n    }\n    /**\n     * Unsubscribes to messages from the specified application on the specified topic.\n     * @param { Identity } source This object is described in the Identity in the typedef\n     * @param { string } topic The topic on which the message is sent\n     * @param { function } listener A callback previously registered with subscribe()\n     * @return {Promise.<void>}\n     * @tutorial InterApplicationBus.unsubscribe\n     */\n    unsubscribe(source, topic, listener) {\n        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);\n        const sendUnsubscription = () => {\n            return this.wire.sendAction('unsubscribe', {\n                sourceUuid: source.uuid,\n                sourceWindowName: source.name || '*',\n                topic,\n                destinationWindowName: this.me.name\n            });\n        };\n        const dontSendUnsubscription = () => {\n            // tslint:disable-next-line\n            return new Promise(r => r).then(() => undefined);\n        };\n        this.emitter.removeListener(subKey, listener);\n        return this.refCounter.actOnLast(subKey, sendUnsubscription, dontSendUnsubscription);\n    }\n    processMessage(message) {\n        const { payload: { message: payloadMessage, sourceWindowName, sourceUuid, topic } } = message;\n        const keys = [\n            this.createSubscriptionKey(sourceUuid, sourceWindowName, topic),\n            this.createSubscriptionKey(sourceUuid, '*', topic),\n            this.createSubscriptionKey('*', '*', topic)\n        ];\n        const idOfSender = { uuid: sourceUuid, name: sourceWindowName };\n        keys.forEach((key) => {\n            this.emitter.emit(key, payloadMessage, idOfSender);\n        });\n    }\n    emitSubscriverEvent(type, message) {\n        const { payload: { name, uuid, topic } } = message;\n        const payload = { name, uuid, topic };\n        this.emitter.emit(type, payload);\n    }\n    createSubscriptionKey(uuid, name, topic) {\n        const n = name || '*';\n        if (!(uuid && n && topic)) {\n            throw new Error('Missing uuid, name, or topic string');\n        }\n        return createKey(uuid, n, topic);\n    }\n    onmessage(message) {\n        const { action } = message;\n        switch (action) {\n            case 'process-message':\n                this.processMessage(message);\n                break;\n            case this.events.subscriberAdded:\n                this.emitSubscriverEvent(this.events.subscriberAdded, message);\n                break;\n            case this.events.subscriberRemoved:\n                this.emitSubscriverEvent(this.events.subscriberRemoved, message);\n                break;\n            default: break;\n        }\n        return true;\n    }\n}\nexports.default = InterApplicationBus;\nclass InterAppPayload {\n}\nexports.InterAppPayload = InterAppPayload;\nfunction createKey(...toHash) {\n    return toHash.map((item) => {\n        return (new Buffer('' + item)).toString('base64');\n    }).join('/');\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/api/interappbus/interappbus.ts?");

/***/ }),

/***/ "./src/api/notification/notification.ts":
/*!**********************************************!*\
  !*** ./src/api/notification/notification.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst events = {\n    show: 'show',\n    close: 'close',\n    error: 'error',\n    click: 'click',\n    message: 'message'\n};\nclass NotificationOptions {\n    // tslint:disable-next-line\n    constructor(options = {}, identity, notificationId) {\n        const { url, message, timeout, ignoreMouseOver } = options;\n        this.url = url;\n        this.message = message || null;\n        this.timeout = timeout;\n        this.notificationId = notificationId;\n        this.uuidOfProxiedApp = identity.uuid;\n        this.ignoreMouseOver = ignoreMouseOver;\n    }\n}\nexports.NotificationOptions = NotificationOptions;\n/**\n * @classdesc A Notification object represents a window on OpenFin Runtime which\n * is shown briefly to the user on the bottom-right corner of the primary monitor.\n * A notification is typically used to alert the user of some important event which\n * requires his or her attention. Notifications are a child or your application that\n * are controlled by the runtime.\n * @class\n * @alias Notification\n * @hideconstructor\n */\n// tslint:disable-next-line\nclass _Notification extends base_1.EmitterBase {\n    constructor(wire, options) {\n        super(wire, ['notification', '' + options.notificationId]);\n        this.listenerList = ['newListener'];\n        this.unhookAllListeners = () => {\n            this.listenerList.forEach(event => {\n                this.removeAllListeners(event);\n            });\n            this.listenerList.length = 0;\n        };\n        this.options = options;\n        this.url = options.url;\n        this.timeout = options.timeout;\n        this.message = options.message;\n        this.notificationId = options.notificationId;\n        this.on('newListener', (event) => {\n            this.listenerList.push(event);\n        });\n        // give any user added listeners a chance to run then unhook\n        this.on('close', () => {\n            setTimeout(this.unhookAllListeners, 1);\n        });\n    }\n    /**\n     * Invoked when the notification is shown\n     * @return {Promise.<void>}\n     * @tutorial Notification.show\n     */\n    async show() {\n        if (!this.url) {\n            throw new Error('Notifications require a url');\n        }\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'create-notification',\n            payload: {\n                url: this.url,\n                notificationId: this.options.notificationId,\n                message: {\n                    message: this.message\n                },\n                timeout: this.timeout\n            }\n        });\n    }\n    /**\n     * Sends a message to the notification.\n     * @param { any } message The message to be sent to the notification.\n     * Can be either a primitive data type (string, number, or boolean)\n     * or composite data type (object, array) that is composed of other\n     * primitive or composite data types\n     * @return {Promise.<void>}\n     * @tutorial Notification.sendMessage\n     */\n    async sendMessage(message) {\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'send-notification-message',\n            payload: {\n                notificationId: this.options.notificationId,\n                message: {\n                    message\n                }\n            }\n        });\n    }\n    /**\n     * Closes the notification\n     * @return {Promise.<void>}\n     * @tutorial Notification.close\n     */\n    async close() {\n        await this.wire.sendAction('send-action-to-notifications-center', {\n            action: 'close-notification',\n            payload: {\n                notificationId: this.options.notificationId\n            }\n        });\n    }\n}\nexports._Notification = _Notification;\n/**\n * @lends Notification\n */\n// tslint:disable-next-line\nclass _NotificationModule extends base_1.Base {\n    constructor() {\n        super(...arguments);\n        this.nextNoteId = 0;\n        this.events = events;\n    }\n    genNoteId() {\n        // tslint:disable-next-line\n        return ++this.nextNoteId;\n    }\n    ;\n    /**\n     * Creates a new Notification.\n     * @param { object } options\n     * @return {_Notification}\n     * @tutorial Notification.create\n     * @static\n     */\n    create(options) {\n        const noteOptions = new NotificationOptions(options, this.me, this.genNoteId());\n        return new _Notification(this.wire, noteOptions);\n    }\n    ;\n}\nexports.default = _NotificationModule;\n\n\n//# sourceURL=webpack:///./src/api/notification/notification.ts?");

/***/ }),

/***/ "./src/api/system/system.ts":
/*!**********************************!*\
  !*** ./src/api/system/system.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst transport_errors_1 = __webpack_require__(/*! ../../transport/transport-errors */ \"./src/transport/transport-errors.ts\");\nconst window_1 = __webpack_require__(/*! ../window/window */ \"./src/api/window/window.ts\");\n/**\n * An object representing the core of OpenFin Runtime. Allows the developer\n * to perform system-level actions, such as accessing logs, viewing processes,\n * clearing the cache and exiting the runtime as well as listen to <a href=\"tutorial-System.EventEmitter.html\">system events</a>.\n * @namespace\n */\nclass System extends base_1.EmitterBase {\n    constructor(wire) {\n        super(wire, ['system']);\n    }\n    sendExternalProcessRequest(action, options) {\n        return new Promise((resolve, reject) => {\n            const exitEventKey = 'external-process-exited';\n            let processUuid;\n            let externalProcessExitHandler;\n            let ofWindow;\n            if (typeof options.listener === 'function') {\n                externalProcessExitHandler = (payload) => {\n                    const data = payload || {};\n                    const exitPayload = {\n                        topic: 'exited',\n                        uuid: data.processUuid || '',\n                        exitCode: data.exitCode || 0\n                    };\n                    if (processUuid === payload.processUuid) {\n                        options.listener(exitPayload);\n                        ofWindow.removeListener(exitEventKey, externalProcessExitHandler);\n                    }\n                };\n                // window constructor expects the name is not undefined\n                if (!this.wire.me.name) {\n                    this.wire.me.name = this.wire.me.uuid;\n                }\n                ofWindow = new window_1._Window(this.wire, this.wire.me);\n                ofWindow.on(exitEventKey, externalProcessExitHandler);\n            }\n            this.wire.sendAction(action, options)\n                .then(({ payload }) => {\n                processUuid = payload.data.uuid;\n                resolve(payload.data);\n            }).catch((err) => {\n                if (ofWindow) {\n                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);\n                }\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function addListener\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function on\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function once\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Adds a listener to the beginning of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependListener\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * The listener is added to the beginning of the listeners array.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependOnceListener\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Remove a listener from the listener array for the specified event.\n     * Caution: Calling this method changes the array indices in the listener array behind the listener.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function removeListener\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Removes all listeners, or those of the specified event.\n     * @param { string | symbol } [eventType]  - The type of the event.\n     * @return {Promise.<this>}\n     * @function removeAllListeners\n     * @memberof System\n     * @instance\n     * @tutorial System.EventEmitter\n     */\n    /**\n     * Returns the version of the runtime. The version contains the major, minor,\n     * build and revision numbers.\n     * @return {Promise.<string>}\n     * @tutorial System.getVersion\n     */\n    getVersion() {\n        return this.wire.sendAction('get-version')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Clears cached data containing application resource\n     * files (images, HTML, JavaScript files), cookies, and items stored in the\n     * Local Storage.\n     * @param { ClearCacheOption } options - See tutorial for more details.\n     * @return {Promise.<void>}\n     * @tutorial System.clearCache\n     */\n    clearCache(options) {\n        return this.wire.sendAction('clear-cache', options).then(() => undefined);\n    }\n    /**\n     * Clears all cached data when OpenFin Runtime exits.\n     * @return {Promise.<void>}\n     * @tutorial System.deleteCacheOnExit\n     */\n    deleteCacheOnExit() {\n        return this.wire.sendAction('delete-cache-request').then(() => undefined);\n    }\n    /**\n     * Exits the Runtime.\n     * @return {Promise.<void>}\n     * @tutorial System.exit\n     */\n    exit() {\n        return this.wire.sendAction('exit-desktop').then(() => undefined);\n    }\n    /**\n     * Writes any unwritten cookies data to disk.\n     * @return {Promise.<void>}\n     * @tutorial System.flushCookieStore\n     */\n    flushCookieStore() {\n        return this.wire.sendAction('flush-cookie-store').then(() => undefined);\n    }\n    /**\n     * Retrieves an array of data (name, ids, bounds) for all application windows.\n     * @return {Promise.Array.<WindowInfo>}\n     * @tutorial System.getAllWindows\n     */\n    getAllWindows() {\n        return this.wire.sendAction('get-all-windows')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data for all applications.\n     * @return {Promise.Array.<ApplicationInfo>}\n     * @tutorial System.getAllApplications\n     */\n    getAllApplications() {\n        return this.wire.sendAction('get-all-applications')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves the command line argument string that started OpenFin Runtime.\n     * @return {Promise.<string>}\n     * @tutorial System.getCommandLineArguments\n     */\n    getCommandLineArguments() {\n        return this.wire.sendAction('get-command-line-arguments')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Get the current state of the crash reporter.\n     * @return {Promise.<CrashReporterOption>}\n     * @tutorial System.getCrashReporterState\n     */\n    getCrashReporterState() {\n        return this.wire.sendAction('get-crash-reporter-state').then(({ payload }) => payload.data);\n    }\n    /* <-- Note the one asterisk to hide from jsdoc because we don't want to publish this method anymore.\n     * @deprecated Use {@link System.getMachineId} instead.\n     */\n    getDeviceId() {\n        console.warn('Function is deprecated; use getMachineId instead.');\n        return this.wire.sendAction('get-device-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Start the crash reporter for the browser process if not already running.\n     * You can optionally specify `diagnosticMode` to have the logs sent to\n     * OpenFin on runtime close\n     *\n     * @param { CrashReporterOption } options - configure crash reporter\n     * @return {Promise.<CrashReporterOption>}\n     * @tutorial System.startCrashReporter\n     */\n    startCrashReporter(options) {\n        return new Promise((resolve, reject) => {\n            if (!options.diagnosticMode) {\n                return reject(new Error('diagnosticMode not found in options'));\n            }\n            this.wire.sendAction('start-crash-reporter', options).then(({ payload }) => resolve(payload.data)).catch(err => reject(err));\n        });\n    }\n    /**\n     * Returns a hex encoded hash of the mac address and the currently logged in user name\n     * @return {Promise.<string>}\n     * @tutorial System.getDeviceUserId\n     */\n    getDeviceUserId() {\n        return this.wire.sendAction('get-device-user-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves a frame info object for the uuid and name passed in\n     * @param { string } uuid - The UUID of the target.\n     * @param { string } name - The name of the target.\n     * @return {Promise.<EntityInfo>}\n     * @tutorial System.getEntityInfo\n     */\n    getEntityInfo(uuid, name) {\n        return this.wire.sendAction('get-entity-info', { uuid, name }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the value of a given environment variable on the computer on which the runtime is installed\n     * @return {Promise.<string>}\n     * @tutorial System.getEnvironmentVariable\n     */\n    getEnvironmentVariable(envName) {\n        return this.wire.sendAction('get-environment-variable', {\n            environmentVariables: envName\n        })\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Get current focused window.\n     * @return {Promise.<WindowInfo>}\n     * @tutorial System.getFocusedWindow\n     */\n    getFocusedWindow() {\n        return this.wire.sendAction('get-focused-window').then(({ payload }) => payload.data);\n    }\n    /**\n     * Get currently focused external window.\n     * @return {Promise.<Identity>}\n     * @experimental\n     */\n    async getFocusedExternalWindow() {\n        const { payload: { data } } = await this.wire.sendAction('get-focused-external-window');\n        return data;\n    }\n    /**\n     * Returns an array of all the installed runtime versions in an object.\n     * @return {Promise.<string[]>}\n     * @tutorial System.getInstalledRuntimes\n     */\n    // incompatible with standalone node process.\n    getInstalledRuntimes() {\n        return this.wire.sendAction('get-installed-runtimes')\n            .then(({ payload }) => payload.data.runtimes);\n    }\n    /**\n     * Retrieves the contents of the log with the specified filename.\n     * @param { GetLogRequestType } options A object that id defined by the GetLogRequestType interface\n     * @return {Promise.<string>}\n     * @tutorial System.getLog\n     */\n    getLog(options) {\n        return this.wire.sendAction('view-log', options)\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns a unique identifier (UUID) provided by the machine.\n     * @return {Promise.<string>}\n     * @tutorial System.getMachineId\n     */\n    getMachineId() {\n        return this.wire.sendAction('get-machine-id').then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the minimum (inclusive) logging level that is currently being written to the log.\n     * @return {Promise.<LogLevel>}\n     * @tutorial System.getMinLogLevel\n     */\n    getMinLogLevel() {\n        return this.wire.sendAction('get-min-log-level').then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array containing information for each log file.\n     * @return {Promise.Array<LogInfo>}\n     * @tutorial System.getLogList\n     */\n    getLogList() {\n        return this.wire.sendAction('list-logs')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an object that contains data about the monitor setup of the\n     * computer that the runtime is running on.\n     * @return {Promise.<MonitorInfo>}\n     * @tutorial System.getMonitorInfo\n     */\n    getMonitorInfo() {\n        return this.wire.sendAction('get-monitor-info')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the mouse in virtual screen coordinates (left, top).\n     * @return {Promise.<PointTopLeft>}\n     * @tutorial System.getMousePosition\n     */\n    getMousePosition() {\n        return this.wire.sendAction('get-mouse-position')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of all of the runtime processes that are currently\n     * running. Each element in the array is an object containing the uuid\n     * and the name of the application to which the process belongs.\n     * @return {Promise.Array.<ProcessInfo>}\n     * @tutorial System.getProcessList\n     */\n    getProcessList() {\n        return this.wire.sendAction('process-snapshot')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves the Proxy settings.\n     * @return {Promise.<ProxyInfo>}\n     * @tutorial System.getProxySettings\n     */\n    getProxySettings() {\n        return this.wire.sendAction('get-proxy-settings')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns information about the running Runtime in an object.\n     * @return {Promise.<RuntimeInfo>}\n     * @tutorial System.getRuntimeInfo\n     */\n    getRuntimeInfo() {\n        return this.wire.sendAction('get-runtime-info').then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns information about the running RVM in an object.\n     * @return {Promise.<RVMInfo>}\n     * @tutorial System.getRvmInfo\n     */\n    // incompatible with standalone node process.\n    getRvmInfo() {\n        return this.wire.sendAction('get-rvm-info')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves system information.\n     * @return {Promise.<HostSpecs>}\n     * @tutorial System.getHostSpecs\n     */\n    getHostSpecs() {\n        return this.wire.sendAction('get-host-specs').then(({ payload }) => payload.data);\n    }\n    /**\n     * Runs an executable or batch file. A path to the file must be included in options.\n     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.\n     * <br> Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @param { ExternalProcessRequestType } options A object that is defined in the ExternalProcessRequestType interface\n     * @return {Promise.<Identity>}\n     * @tutorial System.launchExternalProcess\n     */\n    launchExternalProcess(options) {\n        return this.sendExternalProcessRequest('launch-external-process', options);\n    }\n    /**\n     * Monitors a running process. A pid for the process must be included in options.\n     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.\n     * @param { ExternalProcessInfo } options See tutorial for more details\n     * @return {Promise.<Identity>}\n     * @tutorial System.monitorExternalProcess\n     */\n    monitorExternalProcess(options) {\n        return this.sendExternalProcessRequest('monitor-external-process', options);\n    }\n    /**\n     * Writes the passed message into both the log file and the console.\n     * @param { string } level The log level for the entry. Can be either \"info\", \"warning\" or \"error\"\n     * @param { string } message The log message text\n     * @return {Promise.<void>}\n     * @tutorial System.log\n     */\n    log(level, message) {\n        return this.wire.sendAction('write-to-log', { level, message }).then(() => undefined);\n    }\n    /**\n     * Opens the passed URL in the default web browser.\n     * @param { string } url The URL to open\n     * @return {Promise.<void>}\n     * @tutorial System.openUrlWithBrowser\n     */\n    openUrlWithBrowser(url) {\n        return this.wire.sendAction('open-url-with-browser', { url }).then(() => undefined);\n    }\n    /**\n     * Removes the process entry for the passed UUID obtained from a prior call\n     * of fin.System.launchExternalProcess().\n     * @param { string } uuid The UUID for a process obtained from a prior call to fin.desktop.System.launchExternalProcess()\n     * @return {Promise.<void>}\n     * @tutorial System.releaseExternalProcess\n     */\n    releaseExternalProcess(uuid) {\n        return this.wire.sendAction('release-external-process', { uuid }).then(() => undefined);\n    }\n    /**\n     * Shows the Chromium Developer Tools for the specified window\n     * @param { Identity } identity This is a object that is defined by the Identity interface\n     * @return {Promise.<void>}\n     * @tutorial System.showDeveloperTools\n     */\n    showDeveloperTools(identity) {\n        return this.wire.sendAction('show-developer-tools', identity).then(() => undefined);\n    }\n    /**\n     * Attempt to close an external process. The process will be terminated if it\n     * has not closed after the elapsed timeout in milliseconds.<br>\n     * Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @param { TerminateExternalRequestType } options A object defined in the TerminateExternalRequestType interface\n     * @return {Promise.<void>}\n     * @tutorial System.terminateExternalProcess\n     */\n    terminateExternalProcess(options) {\n        return this.wire.sendAction('terminate-external-process', options)\n            .then(() => undefined);\n    }\n    /**\n     * Update the OpenFin Runtime Proxy settings.\n     * @param { ProxyConfig } options A config object defined in the ProxyConfig interface\n     * @return {Promise.<void>}\n     * @tutorial System.updateProxySettings\n     */\n    updateProxySettings(options) {\n        return this.wire.sendAction('update-proxy', options).then(() => undefined);\n    }\n    /**\n     * Downloads the given application asset<br>\n     * Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @param { AppAssetInfo } appAsset App asset object\n     * @return {Promise.<void>}\n     * @tutorial System.downloadAsset\n     */\n    // incompatible with standalone node process.\n    downloadAsset(appAsset, progressListener) {\n        return new Promise((resolve, reject) => {\n            //node.js environment not supported\n            if (this.wire.environment.constructor.name === 'NodeEnvironment') {\n                reject(new transport_errors_1.NotSupportedError('downloadAsset only supported in an OpenFin Render process'));\n                return;\n            }\n            const downloadId = this.wire.environment.getNextMessageId().toString();\n            const dlProgressKey = `asset-download-progress-${downloadId}`;\n            const dlErrorKey = `asset-download-error-${downloadId}`;\n            const dlCompleteKey = `asset-download-complete-${downloadId}`;\n            const dlProgress = (progress) => {\n                const p = {\n                    downloadedBytes: progress.downloadedBytes,\n                    totalBytes: progress.totalBytes\n                };\n                progressListener(p);\n            };\n            const cleanListeners = () => {\n                this.removeListener(dlProgressKey, dlProgress);\n            };\n            const dlError = (r, err) => {\n                const error = err ? err : r;\n                cleanListeners();\n                reject(new transport_errors_1.RuntimeError(error));\n            };\n            const dlComplete = () => {\n                cleanListeners();\n                resolve();\n            };\n            this.on(dlProgressKey, dlProgress);\n            this.once(dlErrorKey, dlError);\n            this.once(dlCompleteKey, dlComplete);\n            const downloadOptions = Object.assign(appAsset, { downloadId });\n            this.wire.sendAction('download-asset', downloadOptions).catch((err) => {\n                cleanListeners();\n                reject(err);\n            });\n        });\n    }\n    /**\n    * Downloads a version of the runtime.\n    * @param { RuntimeDownloadOptions } options - Download options.\n    * @param {Function} [progressListener] - called as the runtime is downloaded with progress information.\n    * @return {Promise.<void>}\n    * @tutorial System.downloadRuntime\n    */\n    downloadRuntime(options, progressListener) {\n        return new Promise((resolve, reject) => {\n            //node.js environment not supported\n            if (this.wire.environment.constructor.name === 'NodeEnvironment') {\n                reject(new transport_errors_1.NotSupportedError('downloadRuntime only supported in an OpenFin Render process'));\n                return;\n            }\n            const downloadId = this.wire.environment.getNextMessageId().toString();\n            const dlProgressKey = `runtime-download-progress-${downloadId}`;\n            const dlErrorKey = `runtime-download-error-${downloadId}`;\n            const dlCompleteKey = `runtime-download-complete-${downloadId}`;\n            const dlProgress = (progress) => {\n                const p = {\n                    downloadedBytes: progress.downloadedBytes,\n                    totalBytes: progress.totalBytes\n                };\n                progressListener(p);\n            };\n            const cleanListeners = () => {\n                this.removeListener(dlProgressKey, dlProgress);\n            };\n            const dlError = (r, err) => {\n                const error = err ? err : r;\n                cleanListeners();\n                reject(new transport_errors_1.RuntimeError(error));\n            };\n            const dlComplete = () => {\n                cleanListeners();\n                resolve();\n            };\n            this.on(dlProgressKey, dlProgress);\n            this.once(dlErrorKey, dlError);\n            this.once(dlCompleteKey, dlComplete);\n            const downloadOptions = Object.assign(options, { downloadId });\n            this.wire.sendAction('download-runtime', downloadOptions).catch((err) => {\n                cleanListeners();\n                reject(err);\n            });\n        });\n    }\n    /**\n    * Download preload scripts from given URLs\n    * @param {DownloadPreloadOption[]} scripts - URLs of preload scripts. See tutorial for more details.\n    * @return {Promise.Array<DownloadPreloadInfo>}\n    * @tutorial System.downloadPreloadScripts\n    */\n    downloadPreloadScripts(scripts) {\n        return this.wire.sendAction('download-preload-scripts', { scripts }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data (name, ids, bounds) for all application windows.\n     * @return {Promise.Array.<Identity>}\n     * @tutorial System.getAllExternalApplications\n     */\n    getAllExternalApplications() {\n        return this.wire.sendAction('get-all-external-applications')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of objects representing information about currently\n     * running user-friendly native windows on the system.<br>\n     * Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @return {Promise.Array.<Identity>}\n     * @experimental\n     */\n    getAllExternalWindows() {\n        return this.wire.sendAction('get-all-external-windows')\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves app asset information.\n     * @param { AppAssetRequest } options\n     * @return {Promise.<AppAssetInfo>}\n     * @tutorial System.getAppAssetInfo\n     */\n    getAppAssetInfo(options) {\n        return this.wire.sendAction('get-app-asset-info', options).then(({ payload }) => payload.data);\n    }\n    /**\n     * Get additional info of cookies.\n     * @param { CookieOption } options - See tutorial for more details.\n     * @return {Promise.Array.<CookieInfo>}\n     * @tutorial System.getCookies\n     */\n    getCookies(options) {\n        return this.wire.sendAction('get-cookies', options).then(({ payload }) => payload.data);\n    }\n    /**\n     * Set the minimum log level above which logs will be written to the OpenFin log\n     * @param { LogLevel } The minimum level (inclusive) above which all calls to log will be written\n     * @return {Promise.<void>}\n     * @tutorial System.setMinLogLevel\n     */\n    setMinLogLevel(level) {\n        return this.wire.sendAction('set-min-log-level', { level }).then(() => undefined);\n    }\n    /**\n     * Retrieves the UUID of the computer on which the runtime is installed\n     * @param { string } uuid The uuid of the running application\n     * @return {Promise.<Entity>}\n     * @tutorial System.resolveUuid\n     */\n    resolveUuid(uuid) {\n        return this.wire.sendAction('resolve-uuid', {\n            entityKey: uuid\n        }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Retrieves an array of data for all external applications\n     * @param { Identity } requestingIdentity This object is described in the Identity typedef\n     * @param { any } data Any data type to pass to the method\n     * @return {Promise.<any>}\n     * @ignore\n     */\n    executeOnRemote(requestingIdentity, data) {\n        data.requestingIdentity = requestingIdentity;\n        return this.wire.ferryAction(data);\n    }\n    /**\n     * Reads the specifed value from the registry.<br>\n     * Note: This method is restricted by default and must be enabled via\n     * <a href=\"https://developers.openfin.co/docs/api-security\">API security settings</a>.\n     * @param { string } rootKey - The registry root key.\n     * @param { string } subkey - The registry key.\n     * @param { string } value - The registry value name.\n     * @return {Promise.<RegistryInfo>}\n     * @tutorial System.readRegistryValue\n     */\n    readRegistryValue(rootKey, subkey, value) {\n        return this.wire.sendAction('read-registry-value', {\n            rootKey: rootKey,\n            subkey: subkey,\n            value: value\n        }).then(({ payload }) => payload.data);\n    }\n    /**\n     * This function call will register a unique id and produce a token.\n     * The token can be used to broker an external connection.\n     * @param { string } uuid - A UUID for the remote connection.\n     * @return {Promise.<ExternalConnection>}\n     * @tutorial System.registerExternalConnection\n     */\n    registerExternalConnection(uuid) {\n        return this.wire.sendAction('register-external-connection', { uuid }).then(({ payload }) => payload.data);\n    }\n    /**\n     * Returns the json blob found in the [desktop owner settings](https://openfin.co/documentation/desktop-owner-settings/)\n     * for the specified service.\n     * More information about desktop services can be found [here](https://developers.openfin.co/docs/desktop-services).\n     * @param { ServiceIdentifier } serviceIdentifier An object containing a name key that identifies the service.\n     * @return {Promise.<ServiceConfiguration>}\n     * @tutorial System.getServiceConfiguration\n     */\n    async getServiceConfiguration(serviceIdentifier) {\n        if (typeof serviceIdentifier.name !== 'string') {\n            throw new Error('Must provide an object with a `name` property having a string value');\n        }\n        const { name } = serviceIdentifier;\n        return this.wire.sendAction('get-service-configuration', { name }).then(({ payload }) => payload.data);\n    }\n}\nexports.default = System;\n\n\n//# sourceURL=webpack:///./src/api/system/system.ts?");

/***/ }),

/***/ "./src/api/webcontents/webcontents.ts":
/*!********************************************!*\
  !*** ./src/api/webcontents/webcontents.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nclass WebContents extends base_1.EmitterBase {\n    constructor(wire, identity, entityType) {\n        super(wire, [entityType, identity.uuid, identity.name]);\n        this.entityType = entityType;\n    }\n    executeJavaScript(code) {\n        return this.wire.sendAction('execute-javascript-in-window', Object.assign({}, this.identity, { code }))\n            .then(() => undefined);\n    }\n    getZoomLevel() {\n        return this.wire.sendAction('get-zoom-level', this.identity).then(({ payload }) => payload.data);\n    }\n    setZoomLevel(level) {\n        return this.wire.sendAction('set-zoom-level', Object.assign({}, this.identity, { level })).then(() => undefined);\n    }\n    navigate(url) {\n        return this.wire.sendAction('navigate-window', Object.assign({}, this.identity, { url })).then(() => undefined);\n    }\n    navigateBack() {\n        return this.wire.sendAction('navigate-window-back', Object.assign({}, this.identity)).then(() => undefined);\n    }\n    async navigateForward() {\n        await this.wire.sendAction('navigate-window-forward', Object.assign({}, this.identity));\n    }\n    stopNavigation() {\n        return this.wire.sendAction('stop-window-navigation', Object.assign({}, this.identity)).then(() => undefined);\n    }\n    reload(ignoreCache = false) {\n        return this.wire.sendAction('reload-window', Object.assign({}, {\n            ignoreCache\n        }, this.identity)).then(() => undefined);\n    }\n}\nexports.WebContents = WebContents;\n\n\n//# sourceURL=webpack:///./src/api/webcontents/webcontents.ts?");

/***/ }),

/***/ "./src/api/window/window.ts":
/*!**********************************!*\
  !*** ./src/api/window/window.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/api/base.ts\");\nconst application_1 = __webpack_require__(/*! ../application/application */ \"./src/api/application/application.ts\");\nconst external_window_1 = __webpack_require__(/*! ../external-window/external-window */ \"./src/api/external-window/external-window.ts\");\nconst validate_1 = __webpack_require__(/*! ../../util/validate */ \"./src/util/validate.ts\");\nconst webcontents_1 = __webpack_require__(/*! ../webcontents/webcontents */ \"./src/api/webcontents/webcontents.ts\");\n/**\n * @lends Window\n */\n// tslint:disable-next-line\nclass _WindowModule extends base_1.Base {\n    /**\n     * Asynchronously returns a Window object that represents an existing window.\n     * @param { Identity } identity\n     * @return {Promise.<_Window>}\n     * @tutorial Window.wrap\n     * @static\n     */\n    async wrap(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new _Window(this.wire, identity);\n    }\n    /**\n     * Synchronously returns a Window object that represents an existing window.\n     * @param { Identity } identity\n     * @return {_Window}\n     * @tutorial Window.wrapSync\n     * @static\n     */\n    wrapSync(identity) {\n        const errorMsg = validate_1.validateIdentity(identity);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n        return new _Window(this.wire, identity);\n    }\n    /**\n     * Creates a new Window.\n     * @param { Window~options } options - Window creation options\n     * @return {Promise.<_Window>}\n     * @tutorial Window.create\n     * @static\n     */\n    create(options) {\n        const win = new _Window(this.wire, { uuid: this.me.uuid, name: options.name });\n        return win.createWindow(options);\n    }\n    /**\n     * Asynchronously returns a Window object that represents the current window\n     * @return {Promise.<_Window>}\n     * @tutorial Window.getCurrent\n     * @static\n     */\n    getCurrent() {\n        return this.wrap(this.wire.me);\n    }\n    /**\n     * Synchronously returns a Window object that represents the current window\n     * @return {_Window}\n     * @tutorial Window.getCurrentSync\n     * @static\n     */\n    getCurrentSync() {\n        return this.wrapSync(this.wire.me);\n    }\n}\nexports.default = _WindowModule;\n/**\n * @typedef {object} Window~options\n * @summary Window creation options.\n * @desc This is the options object required by {@link Window.create Window.create}.\n *\n * Note that `name` is the only required property  albeit the `url` property is usually provided as well\n * (defaults to `\"about:blank\"` when omitted).\n *\n * _This jsdoc typedef mirrors the `WindowOptions` TypeScript interface in `@types/openfin`._\n *\n * @property {object} [accelerator]\n * Enable keyboard shortcuts for devtools, zoom, reload, and reload ignoring cache.\n *\n * @property {boolean} [accelerator.devtools=false]\n * If `true`, enables the devtools keyboard shortcut:<br>\n * `Ctrl` + `Shift` + `I` _(Toggles Devtools)_\n *\n * @property {boolean} [accelerator.reload=false]\n * If `true`, enables the reload keyboard shortcuts:<br>\n * `Ctrl` + `R` _(Windows)_<br>\n * `F5` _(Windows)_<br>\n * `Command` + `R` _(Mac)_\n *\n * @property {boolean} [accelerator.reloadIgnoringCache=false]\n * If `true`, enables the reload-from-source keyboard shortcuts:<br>\n * `Ctrl` + `Shift` + `R` _(Windows)_<br>\n * `Shift` + `F5` _(Windows)_<br>\n * `Command` + `Shift` + `R` _(Mac)_\n *\n * @property {boolean} [accelerator.zoom=false]\n * If `true`, enables the zoom keyboard shortcuts:<br>\n * `Ctrl` + `+` _(Zoom In)_<br>\n * `Ctrl` + `Shift` + `+` _(Zoom In)_<br>\n * `Ctrl` + `-` _(Zoom Out)_<br>\n * `Ctrl` + `Shift` + `-` _(Zoom Out)_<br>\n * `Ctrl` + `Scroll` _(Zoom In & Out)_<br>\n * `Ctrl` + `0` _(Restore to 100%)_\n *\n * @property {object} [alphaMask] - _Experimental._  _Updatable._\n * <br>\n * alphaMask turns anything of matching RGB value transparent.\n * <br>\n * Caveats:\n * * runtime key --disable-gpu is required. Note: Unclear behavior on remote Desktop support\n * * User cannot click-through transparent regions\n * * Not supported on Mac\n * * Windows Aero must be enabled\n * * Won't make visual sense on Pixel-pushed environments such as Citrix\n * * Not supported on rounded corner windows\n * @property {number} [alphaMask.red=-1] 0-255\n * @property {number} [alphaMask.green=-1] 0-255\n * @property {number} [alphaMask.blue=-1] 0-255\n *\n * @property {boolean} [alwaysOnTop=false] - _Updatable._\n * A flag to always position the window at the top of the window stack.\n *\n * @property {object} [api]\n * Configurations for API injection.\n *\n * @property {object} [api.iframe] Configure if the the API should be injected into iframes based on domain.\n *\n * @property {boolean} [api.iframe.crossOriginInjection=false] Controls if the `fin` API object is present for cross origin iframes.\n * @property {boolean} [api.iframe.sameOriginInjection=true] Controls if the `fin` API object is present for same origin iframes.\n *\n * @property {string} [applicationIcon = \"\"] - _Deprecated_ - use `icon` instead.\n *\n * @property {number} [aspectRatio=0] - _Updatable._\n * The aspect ratio of width to height to enforce for the window. If this value is equal to or less than zero,\n * an aspect ratio will not be enforced.\n *\n * @property {boolean} [autoShow=true]\n * A flag to automatically show the window when it is created.\n *\n * @property {string} [backgroundColor=\"#FFF\"]\n * The windows _backfill_ color as a hexadecimal value. Not to be confused with the content background color\n * (`document.body.style.backgroundColor`),\n * this color briefly fills a windows (a) content area before its content is loaded as well as (b) newly exposed\n * areas when growing a window. Setting\n * this value to the anticipated content background color can help improve user experience.\n * Default is white.\n *\n * @property {object} [contentNavigation]\n * Restrict navigation to URLs that match a whitelisted pattern.\n * In the lack of a whitelist, navigation to URLs that match a blacklisted pattern would be prohibited.\n * See [here](https://developer.chrome.com/extensions/match_patterns) for more details.\n * @property {string[]} [contentNavigation.whitelist=[]] List of whitelisted URLs.\n * @property {string[]} [contentNavigation.blacklist=[]] List of blacklisted URLs.\n\n * @property {boolean} [contextMenu=true] - _Updatable._\n * A flag to show the context menu when right-clicking on a window.\n * Gives access to the devtools for the window.\n *\n * @property {object} [contextMenuSettings] - _Updatable._\n * Configure the context menu when right-clicking on a window.\n * @property {boolean} [contextMenuSettings.enable=true] Should the context menu display on right click.\n * @property {boolean} [contextMenuSettings.devtools=true] Should the context menu contain a button for opening devtools.\n * @property {boolean} [contextMenuSettings.reload=true] Should the context menu contain a button for reloading the page.\n *\n * @property {object} [cornerRounding] - _Updatable._\n * Defines and applies rounded corners for a frameless window. **NOTE:** On macOS corner is not ellipse but circle rounded by the\n *  average of _height_ and _width_.\n * @property {number} [cornerRounding.height=0] The height in pixels.\n * @property {number} [cornerRounding.width=0] The width in pixels.\n *\n * @property {any} [customData=\"\"] - _Updatable._\n * A field that the user can attach serializable data to to be ferried around with the window options.\n * _When omitted, the default value of this property is the empty string (`\"\"`)._\n *\n * @property {customRequestHeaders[]} [customRequestHeaders]\n * Defines list of {@link customRequestHeaders} for requests sent by the window.\n *\n * @property {boolean} [defaultCentered=false]\n * Centers the window in the primary monitor. This option overrides `defaultLeft` and `defaultTop`. When `saveWindowState` is `true`,\n * this value will be ignored for subsequent launches in favor of the cached value. **NOTE:** On macOS _defaultCenter_ is\n * somewhat above center vertically.\n *\n * @property {number} [defaultHeight=500]\n * The default height of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent launches\n * in favor of the cached value.\n *\n * @property {number} [defaultLeft=100]\n * The default left position of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent\n * launches in favor of the cached value.\n *\n * @property {number} [defaultTop=100]\n * The default top position of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent\n * launches in favor of the cached value.\n *\n * @property {number} [defaultWidth=800]\n * The default width of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent\n * launches in favor of the cached value.\n *\n * @property {boolean} [frame=true] - _Updatable._\n * A flag to show the frame.\n *\n * @hidden-property {boolean} [hideOnClose=false] - A flag to allow a window to be hidden when the close button is clicked.\n *\n * @property {string} [icon] - _Updatable. Inheritable._\n * A URL for the icon to be shown in the window title bar and the taskbar.\n * _When omitted, inherits from the parent application._\n *\n * @property {number} [maxHeight=-1] - _Updatable._\n * The maximum height of a window. Will default to the OS defined value if set to -1.\n *\n * @property {boolean} [maximizable=true] - _Updatable._\n * A flag that lets the window be maximized.\n *\n * @property {number} [maxWidth=-1] - _Updatable._\n * The maximum width of a window. Will default to the OS defined value if set to -1.\n *\n * @property {number} [minHeight=0] - _Updatable._\n * The minimum height of a window.\n *\n * @property {boolean} [minimizable=true] - _Updatable._\n * A flag that lets the window be minimized.\n *\n * @property {number} [minWidth=0] - _Updatable._\n * The minimum width of a window.\n *\n * @property {string} name\n * The name of the window.\n *\n * @property {number} [opacity=1.0] - _Updatable._\n * A flag that specifies how transparent the window will be.\n * This value is clamped between `0.0` and `1.0`.\n *\n * @property {preloadScript[]} [preloadScripts] - _Inheritable_\n * A list of scripts that are eval'ed before other scripts in the page. When omitted, _inherits_\n * from the parent application.\n *\n * @property {boolean} [resizable=true] - _Updatable._\n * A flag to allow the user to resize the window.\n *\n * @property {object} [resizeRegion] - _Updatable._\n * Defines a region in pixels that will respond to user mouse interaction for resizing a frameless window.\n * @property {number} [resizeRegion.bottomRightCorner=9]\n * The size in pixels of an additional square resizable region located at the bottom right corner of a frameless window.\n * @property {number} [resizeRegion.size=7]\n * The size in pixels.\n * @property {object} [resizeRegion.sides={top:true,right:true,bottom:true,left:true}]\n * Sides that a window can be resized from.\n *\n * @property {boolean} [saveWindowState=true]\n * A flag to cache the location of the window.\n *\n * @property {boolean} [shadow=false]\n * A flag to display a shadow on frameless windows.\n * `shadow` and `cornerRounding` are mutually exclusive.\n * On Windows 7, Aero theme is required.\n *\n * @property {boolean} [showTaskbarIcon=true] - _Updatable._ _Windows_.\n * A flag to show the window's icon in the taskbar.\n *\n * @property {boolean} [smallWindow=false]\n * A flag to specify a frameless window that can be be created and resized to less than 41x36px (width x height).\n * _Note: Caveats of small windows are no Aero Snap and drag to/from maximize._\n *\n * @property {string} [state=\"normal\"]\n * The visible state of the window on creation.\n * One of:\n * * `\"maximized\"`\n * * `\"minimized\"`\n * * `\"normal\"`\n *\n * @property {string} [taskbarIcon=string] - Deprecated - use `icon` instead._Windows_.\n *\n * @property {string} [taskbarIconGroup=<application uuid>] - _Windows_.\n * Specify a taskbar group for the window.\n * _If omitted, defaults to app's uuid (`fin.Application.getCurrentSync().identity.uuid`)._\n *\n * @property {string} [url=\"about:blank\"]\n * The URL of the window.\n *\n * @property {string} [uuid=<application uuid>]\n * The `uuid` of the application, unique within the set of all `Application`s running in OpenFin Runtime.\n * If omitted, defaults to the `uuid` of the application spawning the window.\n * If given, must match the `uuid` of the  application spawning the window.\n * In other words, the application's `uuid` is the only acceptable value, but is the default, so there's\n * really no need to provide it.\n *\n * @property {boolean} [waitForPageLoad=false]\n * When set to `true`, the window will not appear until the `window` object's `load` event fires.\n * When set to `false`, the window will appear immediately without waiting for content to be loaded.\n */\n/**\n * @typedef { object } Area\n * @property { number } height Area's height\n * @property { number } width Area's width\n * @property { number } x X coordinate of area's starting point\n * @property { number } y Y coordinate of area's starting point\n */\n/**\n * @typedef { object } WindowMovementOptions\n * @property { boolean } moveIndependently - Move a window independently of its group or along with its group. Defaults to false.\n */\n/**\n * @typedef {object} Transition\n * @property {Opacity} opacity - The Opacity transition\n * @property {Position} position - The Position transition\n * @property {Size} size - The Size transition\n*/\n/**\n * @typedef {object} TransitionOptions\n * @property {boolean} interrupt - This option interrupts the current animation. When false it pushes\nthis animation onto the end of the animation queue.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n */\n/**\n * @typedef {object} Size\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} width - Optional if height is present. Defaults to the window's current width.\n * @property {number} height - Optional if width is present. Defaults to the window's current height.\n */\n/**\n * @typedef {object} Position\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} left - Defaults to the window's current left position in virtual screen coordinates.\n * @property {number} top - Defaults to the window's current top position in virtual screen coordinates.\n */\n/**\n * @typedef {object} Opacity\n * @property {number} duration - The total time in milliseconds this transition should take.\n * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.\n * @property {number} opacity - This value is clamped from 0.0 to 1.0.\n*/\n/**\n * Bounds is a interface that has the properties of height,\n * width, left, top which are all numbers\n * @typedef { object } Bounds\n * @property { number } height Get the application height bound\n * @property { number } width Get the application width bound\n * @property { number } top Get the application top bound\n * @property { number } left Get the application left bound\n * @property { number } right Get the application right bound\n * @property { number } bottom Get the application bottom bound\n */\n/**\n * @classdesc A basic window that wraps a native HTML window. Provides more fine-grained\n * control over the window state such as the ability to minimize, maximize, restore, etc.\n * By default a window does not show upon instantiation; instead the window's show() method\n * must be invoked manually. The new window appears in the same process as the parent window.\n * It has the ability to listen for <a href=\"tutorial-Window.EventEmitter.html\">window specific events</a>.\n * @class\n * @alias Window\n * @hideconstructor\n */\n// The window.Window name is taken\n// tslint:disable-next-line\nclass _Window extends webcontents_1.WebContents {\n    constructor(wire, identity) {\n        super(wire, identity, 'window');\n        this.identity = identity;\n    }\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function addListener\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Adds a listener to the end of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - Called whenever an event of the specified type occurs.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function on\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function once\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Adds a listener to the beginning of the listeners array for the specified event.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependListener\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.\n     * The listener is added to the beginning of the listeners array.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function prependOnceListener\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Remove a listener from the listener array for the specified event.\n     * Caution: Calling this method changes the array indices in the listener array behind the listener.\n     * @param { string | symbol } eventType  - The type of the event.\n     * @param { Function } listener - The callback function.\n     * @param { SubOptions } [options] - Option to support event timestamps.\n     * @return {Promise.<this>}\n     * @function removeListener\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n     * Removes all listeners, or those of the specified event.\n     * @param { string | symbol } [eventType]  - The type of the event.\n     * @return {Promise.<this>}\n     * @function removeAllListeners\n     * @memberof Window\n     * @instance\n     * @tutorial Window.EventEmitter\n     */\n    /**\n    * Returns the zoom level of the window.\n    * @function getZoomLevel\n    * @memberOf Window\n    * @instance\n    * @return {Promise.<number>}\n    * @tutorial Window.getZoomLevel\n    */\n    /**\n     * Sets the zoom level of the window.\n     * @param { number } level The zoom level\n     * @function setZoomLevel\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.setZoomLevel\n     */\n    /**\n     * Navigates the window to a specified URL. The url must contain the protocol prefix such as http:// or https://.\n     * @param {string} url - The URL to navigate the window to.\n     * @function navigate\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.navigate\n     */\n    /**\n     * Navigates the window back one page.\n     * @function navigateBack\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.navigateBack\n     */\n    /**\n     * Navigates the window forward one page.\n     * @function navigateForward\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.navigateForward\n     */\n    /**\n     * Stops any current navigation the window is performing.\n     * @function stopNavigation\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.stopNavigation\n     */\n    /**\n    * Reloads the window current page\n    * @function reload\n    * @memberOf Window\n    * @instance\n    * @return {Promise.<void>}\n    * @tutorial Window.reload\n    */\n    // create a new window\n    createWindow(options) {\n        return new Promise((resolve, reject) => {\n            const CONSTRUCTOR_CB_TOPIC = 'fire-constructor-callback';\n            // need to call pageResponse, otherwise when a child window is created, page is not loaded\n            const pageResponse = new Promise((resolve) => {\n                // tslint:disable-next-line\n                this.on(CONSTRUCTOR_CB_TOPIC, function fireConstructor(response) {\n                    let cbPayload;\n                    const success = response.success;\n                    const responseData = response.data;\n                    const message = responseData.message;\n                    if (success) {\n                        cbPayload = {\n                            httpResponseCode: responseData.httpResponseCode,\n                            apiInjected: responseData.apiInjected\n                        };\n                    }\n                    else {\n                        cbPayload = {\n                            message: responseData.message,\n                            networkErrorCode: responseData.networkErrorCode,\n                            stack: responseData.stack\n                        };\n                    }\n                    this.removeListener(CONSTRUCTOR_CB_TOPIC, fireConstructor);\n                    resolve({\n                        message: message,\n                        cbPayload: cbPayload,\n                        success: success\n                    });\n                });\n            });\n            //set defaults:\n            if (options.waitForPageLoad === void 0) {\n                options.waitForPageLoad = false;\n            }\n            if (options.autoShow === void 0) {\n                options.autoShow = true;\n            }\n            const windowCreation = this.wire.environment.createChildWindow(options);\n            Promise.all([pageResponse, windowCreation]).then((resolvedArr) => {\n                const pageResolve = resolvedArr[0];\n                if (pageResolve.success) {\n                    resolve(this);\n                }\n                else {\n                    reject(pageResolve);\n                }\n                try {\n                    // this is to enforce a 5.0 contract that the child's main function\n                    // will not fire before the parent's success callback on creation.\n                    // if the child window is not accessible (CORS) this contract does\n                    // not hold.\n                    const webWindow = this.getWebWindow();\n                    webWindow.fin.__internal_.openerSuccessCBCalled();\n                }\n                catch (e) {\n                    //common for main windows, we do not want to expose this error. here just to have a debug target.\n                    //console.error(e);\n                }\n            }).catch(reject);\n        });\n    }\n    windowListFromNameList(identityList) {\n        return identityList.map(({ uuid, name, isExternalWindow }) => {\n            if (isExternalWindow) {\n                return new external_window_1.ExternalWindow(this.wire, { uuid });\n            }\n            else {\n                return new _Window(this.wire, { uuid, name });\n            }\n        });\n    }\n    /**\n     * Retrieves an array of frame info objects representing the main frame and any\n     * iframes that are currently on the page.\n     * @return {Promise.<Array<FrameInfo>>}\n     * @tutorial Window.getAllFrames\n     */\n    getAllFrames() {\n        return this.wire.sendAction('get-all-frames', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the current bounds (top, bottom, right, left, width, height) of the window.\n     * @return {Promise.<Bounds>}\n     * @tutorial Window.getBounds\n    */\n    getBounds() {\n        return this.wire.sendAction('get-window-bounds', this.identity)\n            // tslint:disable-next-line\n            .then(({ payload }) => payload.data);\n    }\n    /**\n     * Gives focus to the window.\n     * @return {Promise.<void>}\n     * @emits _Window#focused\n     * @tutorial Window.focus\n     */\n    focus() {\n        return this.wire.sendAction('focus-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Centers the window on its current screen.\n     * @return {Promise.<void>}\n     * @tutorial Window.center\n     */\n    center() {\n        return this.wire.sendAction('center-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Removes focus from the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.blur\n     */\n    blur() {\n        return this.wire.sendAction('blur-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Brings the window to the front of the window stack.\n     * @return {Promise.<void>}\n     * @tutorial Window.bringToFront\n     */\n    bringToFront() {\n        return this.wire.sendAction('bring-window-to-front', this.identity).then(() => undefined);\n    }\n    /**\n     * Performs the specified window transitions.\n     * @param {Transition} transitions - Describes the animations to perform. See the tutorial.\n     * @param {TransitionOptions} options - Options for the animation. See the tutorial.\n     * @return {Promise.<void>}\n     * @tutorial Window.animate\n     */\n    animate(transitions, options) {\n        return this.wire.sendAction('animate-window', Object.assign({}, {\n            transitions,\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Hides the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.hide\n     */\n    hide() {\n        return this.wire.sendAction('hide-window', this.identity).then(() => undefined);\n    }\n    /**\n     * closes the window application\n     * @param { boolean } [force = false] Close will be prevented from closing when force is false and\n     *  close-requested has been subscribed to for applications main window.\n     * @return {Promise.<void>}\n     * @tutorial Window.close\n    */\n    close(force = false) {\n        return this.wire.sendAction('close-window', Object.assign({}, { force }, this.identity))\n            .then(() => {\n            Object.setPrototypeOf(this, null);\n            return undefined;\n        });\n    }\n    /**\n     * Returns the native OS level Id.\n     * In Windows, it will return the Windows [handle](https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types#HWND).\n     * @return {Promise.<string>}\n     * @tutorial Window.getNativeId\n     */\n    getNativeId() {\n        return this.wire.sendAction('get-window-native-id', this.identity)\n            .then(({ payload }) => payload.data);\n    }\n    /*\n     * @deprecated Use {@link Window.disableUserMovement} instead.\n     */\n    disableFrame() {\n        console.warn('Function is deprecated; use disableUserMovement instead.');\n        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Prevents a user from changing a window's size/position when using the window's frame.\n     * @return {Promise.<void>}\n     * @tutorial Window.disableUserMovement\n     */\n    disableUserMovement() {\n        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);\n    }\n    /*\n     * @deprecated Use {@link Window.enableUserMovement} instead.\n     */\n    enableFrame() {\n        console.warn('Function is deprecated; use enableUserMovement instead.');\n        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Re-enables user changes to a window's size/position when using the window's frame.\n     * @return {Promise.<void>}\n     * @tutorial Window.enableUserMovement\n     */\n    enableUserMovement() {\n        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);\n    }\n    /**\n     * Executes Javascript on the window, restricted to windows you own or windows owned by\n     * applications you have created.\n     * @param { string } code JavaScript code to be executed on the window.\n     * @function executeJavaScript\n     * @memberOf Window\n     * @instance\n     * @return {Promise.<void>}\n     * @tutorial Window.executeJavaScript\n     */\n    /**\n     * Flashes the windows frame and taskbar icon until stopFlashing is called or until a focus event is fired.\n     * @return {Promise.<void>}\n     * @tutorial Window.flash\n     */\n    flash() {\n        return this.wire.sendAction('flash-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Stops the taskbar icon from flashing.\n     * @return {Promise.<void>}\n     * @tutorial Window.stopFlashing\n     */\n    stopFlashing() {\n        return this.wire.sendAction('stop-flash-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Retrieves an array containing wrapped fin.Windows that are grouped with this window.\n     * If a window is not in a group an empty array is returned. Please note that\n     * calling window is included in the result array.\n     * @return {Promise.<Array<_Window|ExternalWindow>>}\n     * @tutorial Window.getGroup\n     */\n    getGroup() {\n        return this.wire.sendAction('get-window-group', Object.assign({}, {\n            crossApp: true // cross app group supported\n        }, this.identity)).then(({ payload }) => {\n            // tslint:disable-next-line\n            let winGroup = [];\n            if (payload.data.length) {\n                winGroup = this.windowListFromNameList(payload.data);\n            }\n            return winGroup;\n        });\n    }\n    /**\n     * Gets an information object for the window.\n     * @return {Promise.<WindowInfo>}\n     * @tutorial Window.getInfo\n     */\n    getInfo() {\n        return this.wire.sendAction('get-window-info', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the current settings of the window.\n     * @return {Promise.<any>}\n     * @tutorial Window.getOptions\n     */\n    getOptions() {\n        return this.wire.sendAction('get-window-options', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the parent application.\n     * @return {Promise.<Application>}\n     * @tutorial Window.getParentApplication\n     */\n    getParentApplication() {\n        return Promise.resolve(new application_1.Application(this.wire, this.identity));\n    }\n    /**\n     * Gets the parent window.\n     * @return {Promise.<_Window>}\n     * @tutorial Window.getParentWindow\n     */\n    getParentWindow() {\n        return Promise.resolve(new application_1.Application(this.wire, this.identity)).then(app => app.getWindow());\n    }\n    /**\n     * Gets a base64 encoded PNG snapshot of the window or just part a of it.\n     * @param { Area } [area] The area of the window to be captured.\n     * Omitting it will capture the whole visible window.\n     * @return {Promise.<string>}\n     * @tutorial Window.getSnapshot\n     */\n    async getSnapshot(area) {\n        const req = Object.assign({}, { area }, this.identity);\n        const res = await this.wire.sendAction('get-window-snapshot', req);\n        return res.payload.data;\n    }\n    /**\n     * Gets the current state (\"minimized\", \"maximized\", or \"restored\") of the window.\n     * @return {Promise.<string>}\n     * @tutorial Window.getState\n     */\n    getState() {\n        return this.wire.sendAction('get-window-state', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Gets the [Window Object](https://developer.mozilla.org/en-US/docs/Web/API/Window) previously getNativeWindow\n     * @return {object}\n     * @tutorial Window.getWebWindow\n     */\n    getWebWindow() {\n        return this.wire.environment.getWebWindow(this.identity);\n    }\n    /**\n     * Determines if the window is a main window.\n     * @return {boolean}\n     * @tutorial Window.isMainWindow\n     */\n    isMainWindow() {\n        return this.me.uuid === this.me.name;\n    }\n    /**\n     * Determines if the window is currently showing.\n     * @return {Promise.<boolean>}\n     * @tutorial Window.isShowing\n     */\n    isShowing() {\n        return this.wire.sendAction('is-window-showing', this.identity).then(({ payload }) => payload.data);\n    }\n    /**\n     * Joins the same window group as the specified window.\n     * Joining a group with native windows is currently not supported(method will nack).\n     * @param { _Window | ExternalWindow } target The window whose group is to be joined\n     * @return {Promise.<void>}\n     * @tutorial Window.joinGroup\n     */\n    joinGroup(target) {\n        return this.wire.sendAction('join-window-group', Object.assign({}, {\n            groupingUuid: target.identity.uuid,\n            groupingWindowName: target.identity.name\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Leaves the current window group so that the window can be move independently of those in the group.\n     * @return {Promise.<void>}\n     * @tutorial Window.leaveGroup\n     */\n    leaveGroup() {\n        return this.wire.sendAction('leave-window-group', this.identity).then(() => undefined);\n    }\n    /**\n     * Maximizes the window\n     * @return {Promise.<void>}\n     * @tutorial Window.maximize\n     */\n    maximize() {\n        return this.wire.sendAction('maximize-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Merges the instance's window group with the same window group as the specified window\n     * @param { _Window | ExternalWindow } target The window whose group is to be merged with\n     * @return {Promise.<void>}\n     * @tutorial Window.mergeGroups\n     */\n    mergeGroups(target) {\n        return this.wire.sendAction('merge-window-groups', Object.assign({}, {\n            groupingUuid: target.identity.uuid,\n            groupingWindowName: target.identity.name\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Minimizes the window.\n     * @return {Promise.<void>}\n     * @tutorial Window.minimize\n     */\n    minimize() {\n        return this.wire.sendAction('minimize-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Moves the window by a specified amount.\n     * @param { number } deltaLeft The change in the left position of the window\n     * @param { number } deltaTop The change in the top position of the window\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.moveBy\n     */\n    moveBy(deltaLeft, deltaTop, options = { moveIndependently: false }) {\n        return this.wire.sendAction('move-window-by', Object.assign({}, {\n            deltaLeft,\n            deltaTop,\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Moves the window to a specified location.\n     * @param { number } left The left position of the window\n     * @param { number } top The top position of the window\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.moveTo\n     */\n    moveTo(left, top, options = { moveIndependently: false }) {\n        return this.wire.sendAction('move-window', Object.assign({}, {\n            left,\n            top,\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Resizes the window by a specified amount.\n     * @param { number } deltaWidth The change in the width of the window\n     * @param { number } deltaHeight The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\"\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.resizeBy\n     */\n    resizeBy(deltaWidth, deltaHeight, anchor, options = { moveIndependently: false }) {\n        return this.wire.sendAction('resize-window-by', Object.assign({}, {\n            deltaWidth: Math.floor(deltaWidth),\n            deltaHeight: Math.floor(deltaHeight),\n            anchor,\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Resizes the window to the specified dimensions.\n     * @param { number } width The change in the width of the window\n     * @param { number } height The change in the height of the window\n     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.\n     * Can take the values: \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\".\n     * If undefined, the default is \"top-left\"\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.resizeTo\n     */\n    resizeTo(width, height, anchor, options = { moveIndependently: false }) {\n        return this.wire.sendAction('resize-window', Object.assign({}, {\n            width: Math.floor(width),\n            height: Math.floor(height),\n            anchor,\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Restores the window to its normal state (i.e., unminimized, unmaximized).\n     * @return {Promise.<void>}\n     * @tutorial Window.restore\n     */\n    restore() {\n        return this.wire.sendAction('restore-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Will bring the window to the front of the entire stack and give it focus.\n     * @return {Promise.<void>}\n     * @tutorial Window.setAsForeground\n     */\n    setAsForeground() {\n        return this.wire.sendAction('set-foreground-window', this.identity).then(() => undefined);\n    }\n    /**\n     * Sets the window's size and position.\n     * @property { Bounds } bounds This is a * @type {string} name - name of the window.object that holds the propertys of\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.setBounds\n     */\n    setBounds(bounds, options = { moveIndependently: false }) {\n        return this.wire.sendAction('set-window-bounds', Object.assign({}, Object.assign({}, bounds, { options }), this.identity)).then(() => undefined);\n    }\n    /**\n     * Shows the window if it is hidden.\n     * @param { boolean } [force = false] Show will be prevented from showing when force is false and\n     *  show-requested has been subscribed to for applications main window.\n     * @return {Promise.<void>}\n     * @tutorial Window.show\n     */\n    show(force = false) {\n        return this.wire.sendAction('show-window', Object.assign({}, { force }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Shows the window if it is hidden at the specified location.\n     * If the toggle parameter is set to true, the window will\n     * alternate between showing and hiding.\n     * @param { number } left The left position of the window\n     * @param { number } top The right position of the window\n     * @param { boolean } force Show will be prevented from closing when force is false and\n     * show-requested has been subscribed to for applications main window\n     * @param { WindowMovementOptions } options Optional parameters to modify window movement\n     * @return {Promise.<void>}\n     * @tutorial Window.showAt\n     */\n    showAt(left, top, force = false, options = { moveIndependently: false }) {\n        return this.wire.sendAction('show-at-window', Object.assign({}, {\n            force,\n            left: Math.floor(left),\n            top: Math.floor(top),\n            options\n        }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Shows the Chromium Developer Tools\n     * @return {Promise.<void>}\n     * @tutorial Window.showDeveloperTools\n     */\n    showDeveloperTools() {\n        return this.wire.sendAction('show-developer-tools', this.identity).then(() => undefined);\n    }\n    /**\n     * Updates the window using the passed options.\n     * Values that are objects are deep-merged, overwriting only the values that are provided.\n     * @param {*} options Changes a window's options that were defined upon creation. See tutorial\n     * @return {Promise.<void>}\n     * @tutorial Window.updateOptions\n     */\n    updateOptions(options) {\n        return this.wire.sendAction('update-window-options', Object.assign({}, { options }, this.identity)).then(() => undefined);\n    }\n    /**\n     * Provides credentials to authentication requests\n     * @param { string } userName userName to provide to the authentication challenge\n     * @param { string } password password to provide to the authentication challenge\n     * @return {Promise.<void>}\n     * @tutorial Window.authenticate\n     */\n    authenticate(userName, password) {\n        return this.wire.sendAction('window-authenticate', Object.assign({}, { userName, password }, this.identity)).then(() => undefined);\n    }\n}\nexports._Window = _Window;\n\n\n//# sourceURL=webpack:///./src/api/window/window.ts?");

/***/ }),

/***/ "./src/environment/openfin-env.ts":
/*!****************************************!*\
  !*** ./src/environment/openfin-env.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst transport_errors_1 = __webpack_require__(/*! ../transport/transport-errors */ \"./src/transport/transport-errors.ts\");\nclass OpenFinEnvironment {\n    constructor() {\n        this.writeToken = (path, token) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.retrievePort = (config) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.getNextMessageId = () => {\n            return fin.desktop.getUuid();\n        };\n        this.createChildWindow = (options) => {\n            return new Promise((resolve, reject) => {\n                const { uuid: parentUuid } = fin.__internal_.initialOptions;\n                const opt = JSON.parse(JSON.stringify(options));\n                const ABOUT_BLANK = 'about:blank';\n                if (!opt.name || typeof opt.name !== 'string') {\n                    return reject(new Error('Window must have a name'));\n                }\n                opt.uuid = opt.uuid || parentUuid;\n                opt.url = opt.url || ABOUT_BLANK;\n                if (opt.uuid !== parentUuid) {\n                    return reject(new Error('Child window uuid must match the parent window\\'s uuid: ' + parentUuid));\n                }\n                if (this.isWindowExists(opt.uuid, opt.name)) {\n                    return reject(new Error('Trying to create a window that already exists'));\n                }\n                // we should register the window name with the core asap to prevent\n                // multiple windows claiming the same uuid-name combo\n                fin.__internal_.registerWindowName(opt.uuid, opt.name);\n                if (opt.url !== ABOUT_BLANK) {\n                    opt.url = this.resolveUrl(opt.url);\n                }\n                fin.__internal_.createChildWindow(opt, (childWin) => {\n                    resolve(childWin);\n                });\n            });\n        };\n        this.getRandomId = () => {\n            const intArray = new Uint32Array(1);\n            return window.crypto.getRandomValues(intArray)[0].toString(32);\n        };\n        this.isWindowExists = (uuid, name) => {\n            return fin.__internal_.windowExists(uuid, name);\n        };\n        this.getWebWindow = (identity) => {\n            return fin.__internal_.getWebWindow(identity.name);\n        };\n        this.getCurrentEntityIdentity = () => {\n            return fin.__internal_.entityInfo;\n        };\n    }\n    resolveUrl(url) {\n        const newUrl = new URL(url, location.href);\n        return newUrl.href;\n    }\n}\nexports.default = OpenFinEnvironment;\n\n\n//# sourceURL=webpack:///./src/environment/openfin-env.ts?");

/***/ }),

/***/ "./src/environment/openfin-renderer-api.ts":
/*!*************************************************!*\
  !*** ./src/environment/openfin-renderer-api.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//TODO: IPC gets deleted by the javascript adapter at the moment.\nexports.ipc = fin.__internal_.ipc;\nexports.routingId = fin.__internal_.routingId;\nexports.CORE_MESSAGE_CHANNEL = fin.__internal_.ipcconfig.channels.CORE_MESSAGE;\nexports.outboundTopic = 'of-window-message';\nexports.inboundTopic = `${exports.CORE_MESSAGE_CHANNEL}-${exports.routingId}`;\nexports.currentWindowIdentity = fin.__internal_.getWindowIdentity();\n\n\n//# sourceURL=webpack:///./src/environment/openfin-renderer-api.ts?");

/***/ }),

/***/ "./src/of-main.ts":
/*!************************!*\
  !*** ./src/of-main.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fin_1 = __webpack_require__(/*! ./api/fin */ \"./src/api/fin.ts\");\nconst openfin_renderer_api_1 = __webpack_require__(/*! ./environment/openfin-renderer-api */ \"./src/environment/openfin-renderer-api.ts\");\nconst transport_1 = __webpack_require__(/*! ./transport/transport */ \"./src/transport/transport.ts\");\nconst elipc_1 = __webpack_require__(/*! ./transport/elipc */ \"./src/transport/elipc.ts\");\nconst openfin_env_1 = __webpack_require__(/*! ./environment/openfin-env */ \"./src/environment/openfin-env.ts\");\nconst environment = new openfin_env_1.default();\nconst transport = new transport_1.default(elipc_1.default, environment);\ntransport.connectSync(Object.assign({}, openfin_renderer_api_1.currentWindowIdentity));\nwindow.fin = Object.assign(window.fin, new fin_1.default(transport));\n\n\n//# sourceURL=webpack:///./src/of-main.ts?");

/***/ }),

/***/ "./src/transport/elipc.ts":
/*!********************************!*\
  !*** ./src/transport/elipc.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nconst transport_errors_1 = __webpack_require__(/*! ./transport-errors */ \"./src/transport/transport-errors.ts\");\nconst openfin_renderer_api_1 = __webpack_require__(/*! ../environment/openfin-renderer-api */ \"./src/environment/openfin-renderer-api.ts\");\nclass ElIPCTransport extends events_1.EventEmitter {\n    constructor(onmessage) {\n        super();\n        this.wire = openfin_renderer_api_1.ipc;\n        this.connectSync = () => {\n            openfin_renderer_api_1.ipc.on(openfin_renderer_api_1.inboundTopic, (sender, data) => {\n                try {\n                    this.onmessage(JSON.parse(data));\n                }\n                catch (err) {\n                    //Do something of value here.\n                    throw err;\n                }\n            });\n        };\n        this.connect = (address) => {\n            throw new transport_errors_1.NotImplementedError('Not Implemented');\n        };\n        this.onmessage = onmessage;\n    }\n    send(data, flags) {\n        openfin_renderer_api_1.ipc.send(openfin_renderer_api_1.routingId, openfin_renderer_api_1.outboundTopic, data);\n        return Promise.resolve();\n    }\n    shutdown() {\n        return Promise.reject('Not Implemented');\n    }\n}\nElIPCTransport.READY_STATE = wire_1.READY_STATE;\nexports.default = ElIPCTransport;\n\n\n//# sourceURL=webpack:///./src/transport/elipc.ts?");

/***/ }),

/***/ "./src/transport/transport-errors.ts":
/*!*******************************************!*\
  !*** ./src/transport/transport-errors.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nclass DisconnectedError extends Error {\n    constructor(readyState) {\n        super('Expected websocket state OPEN but found ' + wire_1.READY_STATE[readyState]);\n        this.readyState = readyState;\n    }\n}\nexports.DisconnectedError = DisconnectedError;\nclass UnexpectedActionError extends Error {\n}\nexports.UnexpectedActionError = UnexpectedActionError;\nclass DuplicateCorrelationError extends Error {\n}\nexports.DuplicateCorrelationError = DuplicateCorrelationError;\nclass NoAckError extends Error {\n}\nexports.NoAckError = NoAckError;\nclass NotImplementedError extends Error {\n}\nexports.NotImplementedError = NotImplementedError;\nclass NotSupportedError extends Error {\n}\nexports.NotSupportedError = NotSupportedError;\nclass RuntimeError extends Error {\n    constructor(data) {\n        const payload = data.payload || data;\n        const { reason, error } = payload;\n        super(reason);\n        this.name = 'RuntimeError';\n        if (error && error.stack) {\n            this.stack = error.stack;\n        }\n    }\n}\nexports.RuntimeError = RuntimeError;\n\n\n//# sourceURL=webpack:///./src/transport/transport-errors.ts?");

/***/ }),

/***/ "./src/transport/transport.ts":
/*!************************************!*\
  !*** ./src/transport/transport.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wire_1 = __webpack_require__(/*! ./wire */ \"./src/transport/wire.ts\");\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst transport_errors_1 = __webpack_require__(/*! ./transport-errors */ \"./src/transport/transport-errors.ts\");\nconst eventAggregator_1 = __webpack_require__(/*! ../api/events/eventAggregator */ \"./src/api/events/eventAggregator.ts\");\nclass Transport extends events_1.EventEmitter {\n    constructor(wireType, environment) {\n        super();\n        this.wireListeners = new Map();\n        this.topicRefMap = new Map();\n        this.eventAggregator = new eventAggregator_1.EventAggregator();\n        this.messageHandlers = [this.eventAggregator.dispatchEvent];\n        this.connectSync = (config) => {\n            const { uuid, name } = config;\n            this.me = { uuid, name };\n            this.wire.connectSync();\n        };\n        /* `READY_STATE` is an instance var set by `constructor` to reference the `WebTransportSocket.READY_STATE` enum.\n         * This is syntactic sugar that makes the enum accessible through the `wire` property of the various `fin` singletons.\n         * For example, `fin.system.wire.READY_STATE` is a shortcut to `fin.system.wire.wire.constructor.READY_STATE`.\n         * However it is accessed, the enum is useful for interrogating the state of the web socket on send failure.\n         * The `err.readyState` value is passed to the `reject` handler of the promise returned by either of\n         * `sendAction` or `ferryAction`, and hence all the API methods in the various `fin` singletons that call them.\n         * The enum can be used in two distinct ways by the `reject` handler (using `fin.System.getVersion` by way of example):\n         * 1. State name by state value:\n         * fin.system.getVersion().catch(err => { console.log('State:', fin.system.wire.READY_STATE[err.readyState]); });\n         * 2. State value by state name:\n         * fin.system.getVersion().catch(err => { console.log('Closed:', err.readyState === fin.system.wire.READY_STATE.CLOSED); });\n         * Note that `reject` is called when and only when `readyState` is not `OPEN`.\n         */\n        this.READY_STATE = wire_1.READY_STATE;\n        this.wire = new wireType(this.onmessage.bind(this));\n        this.environment = environment;\n        this.sendRaw = this.wire.send.bind(this.wire);\n        this.registerMessageHandler(this.handleMessage.bind(this));\n        this.wire.on('disconnected', () => {\n            for (const [, { reject }] of this.wireListeners) {\n                reject('Remote connection has closed');\n            }\n            this.wireListeners.clear();\n            this.emit('disconnected');\n        });\n    }\n    async connect(config) {\n        if (wire_1.isExistingConnectConfig(config)) {\n            return this.connectByPort(config);\n        }\n        else if (wire_1.isNewConnectConfig(config)) {\n            const port = await this.environment.retrievePort(config);\n            return this.connectByPort(Object.assign({}, config, { address: `ws://localhost:${port}` }));\n        }\n    }\n    async connectByPort(config) {\n        const { address, uuid, name } = config;\n        const reqAuthPayload = Object.assign({}, config, { type: 'file-token' });\n        this.me = { uuid, name };\n        await this.wire.connect(address);\n        const requestExtAuthRet = await this.sendAction('request-external-authorization', {\n            uuid,\n            type: 'file-token'\n        }, true);\n        if (requestExtAuthRet.action !== 'external-authorization-response') {\n            throw new transport_errors_1.UnexpectedActionError(requestExtAuthRet.action);\n        }\n        const token = requestExtAuthRet.payload.token;\n        await this.environment.writeToken(requestExtAuthRet.payload.file, requestExtAuthRet.payload.token);\n        const requestAuthRet = await this.sendAction('request-authorization', reqAuthPayload, true);\n        if (requestAuthRet.action !== 'authorization-response') {\n            throw new transport_errors_1.UnexpectedActionError(requestAuthRet.action);\n        }\n        else if (requestAuthRet.payload.success !== true) {\n            throw new transport_errors_1.RuntimeError(requestAuthRet.payload);\n        }\n        else {\n            return token;\n        }\n    }\n    sendAction(action, payload = {}, uncorrelated = false) {\n        return new Promise((resolve, reject) => {\n            const id = this.environment.getNextMessageId();\n            const msg = {\n                action,\n                payload,\n                messageId: id\n            };\n            return this.wire.send(msg)\n                .then(() => this.addWireListener(id, resolve, reject, uncorrelated))\n                .catch(reject);\n        });\n    }\n    ferryAction(data) {\n        return new Promise((resolve, reject) => {\n            const id = this.environment.getNextMessageId();\n            data.messageId = id;\n            const resolver = (data) => { resolve(data.payload); };\n            return this.wire.send(data)\n                .then(() => this.addWireListener(id, resolver, reject, false))\n                .catch(reject);\n        });\n    }\n    registerMessageHandler(handler) {\n        this.messageHandlers.push(handler);\n    }\n    addWireListener(id, resolve, reject, uncorrelated) {\n        if (uncorrelated) {\n            this.uncorrelatedListener = resolve;\n        }\n        else if (this.wireListeners.has(id)) {\n            reject(new transport_errors_1.DuplicateCorrelationError(String(id)));\n        }\n        else {\n            this.wireListeners.set(id, { resolve, reject });\n        }\n        // Timeout and reject()?\n    }\n    // This method executes message handlers until the _one_ that handles the message (returns truthy) has run\n    onmessage(data) {\n        for (const h of this.messageHandlers) {\n            h.call(null, data);\n        }\n    }\n    handleMessage(data) {\n        // tslint:disable-next-line\n        const id = data.correlationId || NaN;\n        if (!('correlationId' in data)) {\n            if (this.uncorrelatedListener) {\n                this.uncorrelatedListener.call(null, data);\n            }\n            // tslint:disable-next-line\n            this.uncorrelatedListener = () => { };\n        }\n        else if (!this.wireListeners.has(id)) {\n            return false;\n        }\n        else {\n            const { resolve, reject } = this.wireListeners.get(id);\n            if (data.action !== 'ack') {\n                reject(new transport_errors_1.NoAckError(data.action));\n            }\n            else if (!('payload' in data)) {\n                reject(new transport_errors_1.RuntimeError(data));\n            }\n            else if (!data.payload.success) {\n                reject(new transport_errors_1.RuntimeError(data.payload));\n            }\n            else {\n                resolve.call(null, data);\n            }\n            this.wireListeners.delete(id);\n        }\n        return true;\n    }\n}\nexports.default = Transport;\nclass Message {\n}\nexports.Message = Message;\nclass EventMessage {\n}\nexports.EventMessage = EventMessage;\nclass NotificationEventMessage {\n}\nexports.NotificationEventMessage = NotificationEventMessage;\nclass Payload {\n}\nexports.Payload = Payload;\nclass AuthorizationPayload {\n}\nexports.AuthorizationPayload = AuthorizationPayload;\n\n\n//# sourceURL=webpack:///./src/transport/transport.ts?");

/***/ }),

/***/ "./src/transport/wire.ts":
/*!*******************************!*\
  !*** ./src/transport/wire.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isExternalConfig(config) {\n    if (typeof config.manifestUrl === 'string') {\n        return true;\n    }\n}\nexports.isExternalConfig = isExternalConfig;\nfunction isExistingConnectConfig(config) {\n    return hasUuid(config) && typeof config.address === 'string';\n}\nexports.isExistingConnectConfig = isExistingConnectConfig;\nfunction hasUuid(config) {\n    return typeof config.uuid === 'string';\n}\nfunction hasRuntimeVersion(config) {\n    return config.runtime && typeof config.runtime.version === 'string';\n}\nfunction isNewConnectConfig(config) {\n    return hasUuid(config) && hasRuntimeVersion(config);\n}\nexports.isNewConnectConfig = isNewConnectConfig;\nfunction isPortDiscoveryConfig(config) {\n    return (isExternalConfig(config) && hasRuntimeVersion(config)) || isNewConnectConfig(config);\n}\nexports.isPortDiscoveryConfig = isPortDiscoveryConfig;\nfunction isInternalConnectConfig(config) {\n    return isExistingConnectConfig(config) || isNewConnectConfig(config);\n}\nexports.isInternalConnectConfig = isInternalConnectConfig;\nvar READY_STATE;\n(function (READY_STATE) {\n    READY_STATE[READY_STATE[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    READY_STATE[READY_STATE[\"OPEN\"] = 1] = \"OPEN\";\n    READY_STATE[READY_STATE[\"CLOSING\"] = 2] = \"CLOSING\";\n    READY_STATE[READY_STATE[\"CLOSED\"] = 3] = \"CLOSED\"; // The connection is closed.\n})(READY_STATE = exports.READY_STATE || (exports.READY_STATE = {}));\n\n\n//# sourceURL=webpack:///./src/transport/wire.ts?");

/***/ }),

/***/ "./src/util/promises.ts":
/*!******************************!*\
  !*** ./src/util/promises.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction promisify(func) {\n    return (...args) => new Promise((resolve, reject) => {\n        func(...args, (err, val) => err ? reject(err) : resolve(val));\n    });\n}\nexports.promisify = promisify;\nasync function promiseMap(arr, asyncF) {\n    return Promise.all(arr.map(asyncF));\n}\nexports.promiseMap = promiseMap;\nasync function serial(arr) {\n    const ret = [];\n    for (const func of arr) {\n        const next = await func();\n        ret.push(next);\n    }\n    return ret;\n}\nexports.serial = serial;\nasync function promiseMapSerial(arr, func) {\n    return serial(arr.map((value, index, array) => () => func(value, index, array)));\n}\nexports.promiseMapSerial = promiseMapSerial;\n\n\n//# sourceURL=webpack:///./src/util/promises.ts?");

/***/ }),

/***/ "./src/util/ref-counter.ts":
/*!*********************************!*\
  !*** ./src/util/ref-counter.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass RefCoutner {\n    constructor() {\n        this.topicRefMap = new Map();\n    }\n    // returns the ref count after incrementing\n    incRefCount(key) {\n        const refCount = this.topicRefMap.get(key);\n        let returnCount;\n        if (!refCount) {\n            this.topicRefMap.set(key, 1);\n            returnCount = 1;\n        }\n        else {\n            const newRefCount = refCount + 1;\n            returnCount = newRefCount;\n            this.topicRefMap.set(key, newRefCount);\n        }\n        return returnCount;\n    }\n    // returns the ref count after decrementing, or -1 if the key already had no references\n    decRefCount(key) {\n        const refCount = this.topicRefMap.get(key);\n        let returnCount;\n        if (refCount) {\n            const newRefCount = refCount - 1;\n            this.topicRefMap.set(key, newRefCount);\n            returnCount = newRefCount;\n        }\n        else {\n            returnCount = -1;\n        }\n        return returnCount;\n    }\n    // Execute firstAction if it is the first such ref, else execute nonFirstAction.\n    // In either case the return value is that of the action executed\n    // tslint:disable-next-line\n    actOnFirst(key, firstAction, nonFirstAction = () => { }) {\n        const numRefs = this.incRefCount(key);\n        const isFirstRef = numRefs === 1;\n        return isFirstRef ? firstAction() : nonFirstAction();\n    }\n    // Execute lastAction if it is the first such ref, else execute nonLastAction.\n    // In either case the return value is that of the action executed\n    // tslint:disable-next-line\n    actOnLast(key, lastAction, nonLastAction = () => { }) {\n        const numRefs = this.decRefCount(key);\n        const isLastRef = numRefs === 0;\n        return isLastRef ? lastAction() : nonLastAction();\n    }\n}\nexports.default = RefCoutner;\n\n\n//# sourceURL=webpack:///./src/util/ref-counter.ts?");

/***/ }),

/***/ "./src/util/validate.ts":
/*!******************************!*\
  !*** ./src/util/validate.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction validateIdentity(identity) {\n    let errorMsg;\n    if (typeof identity !== 'object' || typeof identity.uuid !== 'string') {\n        errorMsg = 'Not a valid identity object';\n    }\n    return errorMsg;\n}\nexports.validateIdentity = validateIdentity;\n\n\n//# sourceURL=webpack:///./src/util/validate.ts?");

/***/ })

/******/ });